/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Copyright (c) Geoworks 1995 -- All Rights Reserved

PROJECT:	GEOS
MODULE:		SDK_C
FILE:		serial2.goc

AUTHOR:		Ed Ballot

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	EB	7/11/95		Initial Version
	NF	9/5/96		Made change to:
				MSG_SERIAL_DEMO_READ_IN_SERIAL_DATA
	RainerB	8/14/2022	Type mismatch warnings fixed when calling MSG_GEN_USE_VIS_MONIKER
	
DESCRIPTION:
	This sample application illustrates using event driven
	serial notification.  That is, a message or routine will
	be called when a specified number of bytes are received
	into the serial input buffer.  StreamSetMessageNotification()
	and StreamSetThreshold() are the routines used to set up the
	notification message and the number of bytes to buffer before
	calling the notification message.  In this sample application,
	setting up the event notification is done in the routine
	SetupSerialNotify().

	A small amount of error condition checking is performed.  The
	error strings are stored in a chunk array, rather than in
	seperate chunks (as is done in the previous serial sample app).


SPECIAL NOTES:
	The OmniGo 100 device makes special use of the DTR line, so
	serial applications running on that device *cannot* set or
	clear the DTR line.

	This sample application uses a streamC library that shipped after
	the OmniGo 100 device.  Because of this, you will need to use the
	StreamC library that is included in the OmniGo SDK rather than the
	StreamC library that shipped with the OmniGo.

	If you use any of the following routines in your application,
	you will need to ship with and install the newer version of the
	streamC library.  List of routines:
		SerialLoadDriver()
		ParallelLoadDriver()
		StreamSetMessageNotify()
		StreamSetRoutineNotify()
		StreamSetDataRoutineNotify()
		StreamSetNoNotify()
		StreamSetThreshold()

	$Id: serial2.goc,v 1.1 97/04/04 16:39:12 newdeal Exp $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Include Files
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@include <stdapp.goh>		/* Standard GEOS headers.	*/

#include <Ansi/string.h>	/* Standard C.	*/
#include <Ansi/stdio.h>

#include <streamC.h>		/* Additional GEOS headers.	*/



/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Class Definitions & Declarations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*
 * SerialDemoProcessClass will be the only application thread.
 */
@class	SerialDemoProcessClass, GenProcessClass;
    @message void MSG_SERIAL_DEMO_OPEN_CLOSE_PORT();
    @message void MSG_SERIAL_DEMO_SEND_TEXT();
@endc;


@class SerialTriggerClass, GenTriggerClass;
@endc;

@class SerialTextDisplayClass, GenTextClass;
    @message void MSG_SERIAL_DEMO_READ_IN_SERIAL_DATA(
        word numAvail = cx, StreamToken stream = dx, 
        StreamRoles side = bp );
@endc;

@classdecl	SerialDemoProcessClass, neverSaved ;
@classdecl	SerialTextDisplayClass;
@classdecl 	SerialTriggerClass;


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Constants
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/* default serial settings */
#define SERIAL_DEMO_COM_PORT_DEFAULT 	(SERIAL_COM1)
#define SERIAL_DEMO_BAUD_RATE_DEFAULT	(SERIAL_BAUD_9600)
#define SERIAL_DEMO_LENGTH_DEFAULT	(SERIAL_LENGTH_8)
#define SERIAL_DEMO_PARITY_DEFAULT	(SERIAL_PARITY_NONE)
#define	SERIAL_DEMO_XSTOP_BITS_DEFAULT	(SERIAL_XSTOP_NONE)
#define SERIAL_DEMO_MODE_DEFAULT	(SERIAL_MODE_RARE)

/* set different buffers for serial in and serial out. */
#define	SERIAL_DEMO_READ_BUFFER_SIZE	(1000)
#define	SERIAL_DEMO_WRITE_BUFFER_SIZE	(500)

/*
 * This is used in SerialOpen as the amount of time to keep trying
 * to open the serial port before giving up.
 */
#define SERIAL_TIMEOUT	10

/* number of bytes to buffer before sending notification event */
#define STREAM_THRESHOLD 1

/* index for errors in ErrorStringArray.  StreamError takes up slots
 * 0 thru 9, so these errors start at 10. */
#define ERR_COULDNT_OPEN_PORT		10
#define ERR_CANT_ALLOCATE_MEMORY	11
#define ERR_DATA_BUT_NO_MEMORY		12
#define ERR_SERIAL_READ			13
#define ERR_READ_TIMEOUT		14
#define ERR_WRITE_TIMEOUT		15
#define ERR_SEND_DATA_ERROR		16


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Global Variables
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*
 * GeodeHandle of the serial driver.  Needed for all SerialXxx() 
 * routine calls. 
 */
static	GeodeHandle serialDriver   = NullHandle;

/* Used to keep track of the open status of the serial port. */
static	Boolean	serialPortOpen	   = FALSE;

/*
 * These global variables are used to set the format and flow
 * control for the serial port.
 */
static	SerialUnit serialComPort   = SERIAL_DEMO_COM_PORT_DEFAULT;
static	SerialBaud serialBaudRate  = SERIAL_DEMO_BAUD_RATE_DEFAULT;
static	SerialLength serialLength  = SERIAL_DEMO_LENGTH_DEFAULT;
static	SerialParity serialParity  = SERIAL_DEMO_PARITY_DEFAULT;
static	SerialExtraStopBits serialXStopBits =
				     SERIAL_DEMO_XSTOP_BITS_DEFAULT;
static	SerialMode serialMode	   = SERIAL_DEMO_MODE_DEFAULT; /*rare*/

/* buffer used to read in data from the serial in-buffer */
static	MemHandle  readBuffer	= NullHandle;


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Structures and Function Prototypes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/* 32 bytes string structure used by ReportError */
typedef char ErrorString[32];



/* functions for dealing with serial port setup/closing */
static Boolean ChannelSetup(void);
static void ChannelTearDown(void);

/* misc. functions */
static void DisableInvalidComPorts(void);
static void GetSerialSettings(void);
static void SetupSerialNotification(void);
static void ReportError(word errorNum);
static void ReportSerialError(word serialError);




/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		User Interface Definition
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@start	AppResource;

@object GenApplicationClass SerialDemoApp = {
    GI_visMoniker	= list { @SerialTextMoniker }
    GI_comp		= @SerialPrimary;
    gcnList(MANUFACTURER_ID_GEOWORKS,GAGCNLT_WINDOWS) = @SerialPrimary;
}

@visMoniker SerialTextMoniker = "Serial Host Application";

@end	AppResource;


@start	Interface;

@object GenPrimaryClass SerialPrimary = {
    GI_comp		= @SerialMainMenu,
			  @TriggerGroup,
			  @SerialSendBufferDisplay,
			  @SerialRcvBufferDisplay,
			  @SerialErrorDisplay;
    ATTR_GEN_DISPLAY_NOT_MINIMIZABLE;
    HINT_SIZE_WINDOW_AS_DESIRED;
}


@object GenInteractionClass SerialMainMenu = {
    GI_visMoniker	= "Main";
    GI_comp		= @SerialSettingsDialog;
    GII_visibility	= GIV_POPUP;
}

@object GenInteractionClass TriggerGroup = {
    GI_comp = @ConnectTrig, @SendDataTrig;
    HINT_ORIENT_CHILDREN_HORIZONTALLY;
}


@object GenTriggerClass ConnectTrig = {
    GI_visMoniker = list { @OpenConnection };
    GTI_actionMsg = MSG_SERIAL_DEMO_OPEN_CLOSE_PORT;
    GTI_destination = process;
}

@visMoniker OpenConnection  = "Open Connection";
@visMoniker CloseConnection = "Close Connection";



@object GenTriggerClass SendDataTrig = {
    GI_visMoniker = "Send Text";
    GI_states = @default & ~GS_ENABLED; /* so no send data when ! connect */
    GTI_actionMsg = MSG_SERIAL_DEMO_SEND_TEXT;
    GTI_destination = process;
}

@object SerialTextDisplayClass SerialSendBufferDisplay = {
    GI_visMoniker	= "Send Buffer:";
    GTXI_attrs		= @default | GTA_INIT_SCROLLING;
    GTXI_text		= "";
    HINT_EXPAND_HEIGHT_TO_FIT_PARENT;
    HINT_PLACE_MONIKER_ABOVE;
}

@object SerialTextDisplayClass SerialRcvBufferDisplay = {
    GI_visMoniker	= "Receive Buffer:";
    GTXI_attrs		= @default | GTA_INIT_SCROLLING;
    GTXI_text		= "";
    HINT_EXPAND_HEIGHT_TO_FIT_PARENT;
    HINT_PLACE_MONIKER_ABOVE;
}

@object GenTextClass SerialErrorDisplay = {
    GI_visMoniker	= "Status Buffer:";
    GI_attrs		= @default | GA_READ_ONLY;
    GTXI_text		= "";
    HINT_PLACE_MONIKER_ABOVE;
    /* for small screen, give this text less space */
    HINT_IF_SYSTEM_ATTRS = SA_VERTICALLY_TINY;
        HINT_FIXED_SIZE	= { 0, SST_LINES_OF_TEXT | 4, 0 };
    HINT_ELSE;
        HINT_FIXED_SIZE	= { 0, SST_LINES_OF_TEXT | 2, 0 };
    HINT_ENDIF;
}

@end Interface;


/**** objects for setting serial port *****/
@start SerialSettings;

@object GenInteractionClass SerialSettingsDialog = {
    GI_visMoniker	= "Settings";
    GI_comp		= @ComPortGroup,
			  @BaudRateGroup,
			  @ParityBitsGroup,
			  @LengthGroup,
			  @XStopBitsGroup,
			  @ModeGroup;
    GII_type		= GIT_PROPERTIES;
    GII_visibility	= GIV_DIALOG;
    HINT_INTERACTION_SINGLE_USAGE;
    HINT_ORIENT_CHILDREN_VERTICALLY;
}


@object GenInteractionClass ComPortGroup = {
    GI_visMoniker	= "COM port:";
    GI_comp		= @ComPortList;
    GII_type		= GIT_PROPERTIES;
}

@object GenItemGroupClass ComPortList = {
    GI_comp		= @Com1Setting,
			  @Com2Setting,
			  @Com3Setting,
			  @Com4Setting;
    GIGI_selection = SERIAL_DEMO_COM_PORT_DEFAULT;

    HINT_IF_SYSTEM_ATTRS = SA_TINY;
	HINT_ITEM_GROUP_MINIMIZE_SIZE;
	HINT_ITEM_GROUP_DISPLAY_CURRENT_SELECTION;
    HINT_ENDIF;
}

@object GenItemClass Com1Setting = {
    GI_visMoniker	= "COM 1";
    GII_identifier	= SERIAL_COM1;
}
@object GenItemClass Com2Setting = {
    GI_visMoniker	= "COM 2";
    GII_identifier	= SERIAL_COM2;
}
@object GenItemClass Com3Setting = {
    GI_visMoniker	= "COM 3";
    GII_identifier	= SERIAL_COM3;
}
@object GenItemClass Com4Setting = {
    GI_visMoniker	= "COM 4";
    GII_identifier	= SERIAL_COM4;
}


@object GenInteractionClass BaudRateGroup = {
    GI_visMoniker	= "Baud Rate:";
    GI_comp		= @BaudRateList;
    GII_type		= GIT_PROPERTIES;
}

@object GenItemGroupClass BaudRateList = {
    GI_comp		= @Baud2400,
			  @Baud4800,
			  @Baud9600,
			  @Baud14400,
			  @Baud19200;
    GIGI_selection	= SERIAL_DEMO_BAUD_RATE_DEFAULT;

    HINT_IF_SYSTEM_ATTRS = SA_TINY;
	HINT_ITEM_GROUP_MINIMIZE_SIZE;
	HINT_ITEM_GROUP_DISPLAY_CURRENT_SELECTION;
    HINT_ENDIF;
}

@object GenItemClass Baud2400 = {
    GI_visMoniker	= "2400";
    GII_identifier	= SERIAL_BAUD_2400;
}

@object GenItemClass Baud4800 = {
    GI_visMoniker	= "4800";
    GII_identifier	= SERIAL_BAUD_4800;
}

@object GenItemClass Baud9600 = {
    GI_visMoniker	= "9600";
    GII_identifier	= SERIAL_BAUD_9600;
}

@object GenItemClass Baud14400 = {
    GI_visMoniker	= "14400";
    GII_identifier	= SERIAL_BAUD_14400;
}

@object GenItemClass Baud19200 = {
    GI_visMoniker	= "19200";
    GII_identifier	= SERIAL_BAUD_19200;
}


@object GenInteractionClass ParityBitsGroup = {
    GI_visMoniker	= "Parity Bits:";
    GI_comp		= @ParityBitsList;
    GII_type		= GIT_PROPERTIES;
}

@object GenItemGroupClass ParityBitsList = {
    GI_comp		= @ParityNone,
			  @ParityOdd,
			  @ParityEven;
    GIGI_selection	= SERIAL_DEMO_PARITY_DEFAULT;

    HINT_IF_SYSTEM_ATTRS = SA_TINY;
	HINT_ITEM_GROUP_MINIMIZE_SIZE;
	HINT_ITEM_GROUP_DISPLAY_CURRENT_SELECTION;
    HINT_ENDIF;
}

@object GenItemClass ParityNone = {
    GI_visMoniker	= "NONE";
    GII_identifier	= SERIAL_PARITY_NONE;
}

@object GenItemClass ParityOdd = {
    GI_visMoniker	= "ODD";
    GII_identifier	= SERIAL_PARITY_ODD;
}

@object GenItemClass ParityEven = {
    GI_visMoniker	= "EVEN";
    GII_identifier	= SERIAL_PARITY_EVEN;
}


@object GenInteractionClass LengthGroup = {
    GI_comp		= @SerialLengthGlyph,
			  @SerialLengthList;
    GII_type		= GIT_PROPERTIES;
    HINT_ORIENT_CHILDREN_VERTICALLY;
}

@object GenGlyphClass SerialLengthGlyph = {
    GI_visMoniker	= "Data Bits per Frame:";
}

@object GenItemGroupClass SerialLengthList = {
    GI_comp		= @Length5,
			  @Length6,
			  @Length7,
			  @Length8;
    GIGI_selection	= SERIAL_DEMO_LENGTH_DEFAULT;

    HINT_IF_SYSTEM_ATTRS = SA_TINY;
	HINT_ITEM_GROUP_MINIMIZE_SIZE;
	HINT_ITEM_GROUP_DISPLAY_CURRENT_SELECTION;
    HINT_ENDIF;
}

@object GenItemClass Length5 = {
    GI_visMoniker	= "5 bits";
    GII_identifier	= SERIAL_LENGTH_5;
}

@object GenItemClass Length6 = {
    GI_visMoniker	= "6 bits";
    GII_identifier	= SERIAL_LENGTH_6;
}

@object GenItemClass Length7 = {
    GI_visMoniker	= "7 bits";
    GII_identifier	= SERIAL_LENGTH_7;
}

@object GenItemClass Length8 = {
    GI_visMoniker	= "8 bits";
    GII_identifier	= SERIAL_LENGTH_8;
}

@object GenInteractionClass XStopBitsGroup = {
    GI_comp		= @SerialXStopBitsList;
    GII_type		= GIT_PROPERTIES;
    GI_visMoniker	= "Extra Stop Bits: ";
}

@object GenItemGroupClass SerialXStopBitsList = {
    GI_comp		= @XStopNone,
			  @XStopOne;
    GIGI_selection	= SERIAL_DEMO_XSTOP_BITS_DEFAULT;

    HINT_IF_SYSTEM_ATTRS = SA_TINY;
	HINT_ITEM_GROUP_MINIMIZE_SIZE;
	HINT_ITEM_GROUP_DISPLAY_CURRENT_SELECTION;
    HINT_ENDIF;
}

@object GenItemClass XStopNone = {
    GI_visMoniker	= "None";
    GII_identifier	= SERIAL_XSTOP_NONE;
}
@object GenItemClass XStopOne = {
    GI_visMoniker	= "One";
    GII_identifier	= SERIAL_XSTOP_ONE;
}

@object GenInteractionClass ModeGroup = {
    GI_comp		= @SerialModeList;
    GII_type		= GIT_PROPERTIES;
    GI_visMoniker	= "Data Mode:";
}

@object GenItemGroupClass SerialModeList = {
    GI_comp		= @RawMode,
			  @RareMode,
			  @CookedMode;
    GIGI_selection	= SERIAL_DEMO_MODE_DEFAULT;

    HINT_IF_SYSTEM_ATTRS = SA_TINY;
	HINT_ITEM_GROUP_MINIMIZE_SIZE;
	HINT_ITEM_GROUP_DISPLAY_CURRENT_SELECTION;
    HINT_ENDIF;
}

@object GenItemClass RawMode = {
    GI_visMoniker	= "Raw";
    GII_identifier	= SERIAL_MODE_RAW;
}

@object GenItemClass RareMode = {
    GI_visMoniker	= "Rare";
    GII_identifier	= SERIAL_MODE_RARE;
}

@object GenItemClass CookedMode = {
    GI_visMoniker	= "Cooked";
    GII_identifier	= SERIAL_MODE_COOKED;
}

@end SerialSettings;


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		Localizable Constants
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@start	ConstantData;

/*
 * SDSerialDriverLoadError informs the user that the Serial driver could
 * *not* be loaded (and so the application is basically useless).
 */
@chunk	char SDSerialDriverLoadErrorString [] =
		"Unable to load the Serial driver!";

/*
 * The various Errors (enumerated values)
 */
@chunkArray ErrorString ErrorStringArray = {
	/* First 10 strings are StreamError.  These are the errors
	   that are returned by most SerialXxx() routines */
	"no error\r",
	"Stream would block\r",
	"Read/write, but port closing\r",
	"Stream Drv can't alloc buff\r",
	"Stream buffer too large\r",
	"Port not open, action failed\r",
	"Short read/write\r",
	"Port doesn't exist\r",
	"Port in use by another app\r",
	"PowerDriver: can't open port\r",

	/* Other errors */
	"Couldn't open serial port\r",	     /* ERR_COULDNT_OPEN_PORT */
	"Unable to allocate memory\r",       /* ERR_CANT_ALLOCATE_MEMORY */
	"Incoming data, but no memory\r",    /* ERR_DATA_BUT_NO_MEMORY */
	"Error during serial read\r",        /* ERR_SERIAL_READ */
	"SerialRead timeout\r",              /* ERR_READ_TIMEOUT */
	"SerialWrite timeout\r",             /* ERR_WRITE_TIMEOUT */
	"SendData: not all bytes sent\r",    /* ERR_SEND_DATA_ERROR */
	"unknown error\r" };

/*
 * The various SerialErrors (bits)
 */
@chunk	char SerialErrorBit4[] = "SERIAL_ERROR_BREAK\r";
@chunk	char SerialErrorBit3[] = "SERIAL_ERROR_FRAME\r";
@chunk	char SerialErrorBit2[] = "SERIAL_ERROR_PARITY\r";
@chunk	char SerialErrorBit1[] = "SERIAL_ERROR_OVERRUN\r";

@end ConstantData;


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		SerialDemoProcessClass Methods
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		MSG_GEN_PROCESS_OPEN_APPLICATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:	Perform all application startup duties.

PASS: 		AppAttachFlags	attachFlags	= Startup modes.
		MemHandle	launchBlock	= App. launch block.
		MemHandle	extraState	= Previously saved state
						  information (iff restoring
						  from state).
RETURN:		Void.

PSEUDO CODE/STRATEGY:
	Invoke the superclass so that the UI gets built out.
	Load the serial driver.
	Force the user to specify a COM port (and so initiate the opening
	of the COM port with the default settings).

KNOWN DEFECTS/CAVEATS/IDEAS:
	none

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	TM	7/13/93 	Initial Revision.
	JDM	93.07.22	Big cleanup.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
@method SerialDemoProcessClass, MSG_GEN_PROCESS_OPEN_APPLICATION
{

    /* Let the superclass do it's thing.	*/
    @callsuper();

    /* Load the serial driver.	*/
    if(NullHandle == (serialDriver = SerialLoadDriver()))
    {
	/*
	 * Inform the user that the serial driver was *not* loaded.
	 *
	 * Lock down the block containing the (localizable) error
	 * message strings.
	 * Inform the user.
	 * Unlock the string block.
	 */
	MemLock(OptrToHandle(@SDSerialDriverLoadErrorString));
	UserStandardDialog
		((char *) NULL,
		 /* not GIT_MULTIPLE_RESPONSE, so no custom triggers  */
		 (char *) NULL,
		 /* No string arguments. */
		 (char *) NULL,
		 (char *) NULL,
		 /* dialog string */
		 LMemDeref(@SDSerialDriverLoadErrorString),
		 /* dialog type */
		 (CDT_ERROR << CDBF_DIALOG_TYPE_OFFSET) |
		 /* interaction type */
		 (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET));
	MemUnlock(OptrToHandle(@SDSerialDriverLoadErrorString));
    }
    else
    {
	/* double check to see that driver handle is valid */
	ECCheckDriverHandle(serialDriver);

	DisableInvalidComPorts();
    }

}



/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		MSG_GEN_PROCESS_CLOSE_APPLICATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:	Perform all application shutdown duties.

PASS: 		Void.

RETURN:		MemHandle	= Handle of block containing information to
				  save to state.

PSEUDO CODE/STRATEGY:
	Close the serial port.
	Free the serial driver.
	Let the super class shutdown everything else.

KNOWN DEFECTS/CAVEATS/IDEAS:
	none

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	TM	93.07.13	Initial version.
	JDM	93.07.22	Big cleanup.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@method SerialDemoProcessClass, MSG_GEN_PROCESS_CLOSE_APPLICATION
{
    /* Get rid of the driver.	*/
    if(serialDriver != NullHandle)
    {
	/* Shutdown the communication channel.	*/
	ChannelTearDown();

	/*
	 * Free the serial driver.
	 */
	GeodeFreeDriver(serialDriver);
    }

    /* Continue shutting down the rest of the application, as normal. */
    @callsuper();

    /* We aren't saving any state information so return NULL.	*/
    return (NullHandle);
}	/* End of MSG_GEN_PROCESS_CLOSE_APPLICATION.	*/



/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		MSG_SERIAL_DEMO_OPEN_CLOSE_PORT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:	If the port is open, then close it and free the read
		buffer.  Otherwise, attempt to open the port.  If
		open is successful, then allocate memory for the read
		buffer and set up serialfor event notification.

PASS: 		Void.

RETURN:		void.

PSEUDO CODE/STRATEGY:
	If the serial port is open then close it and free the readBuffer
	Otherwise
	  Try to set up the port
	  If port setup is okay then
	    Allocate the readBuffer (if no memory, close serial and error)
	    Enable/disable the various ui for serial open settings
	    Set up serial event notification

KNOWN DEFECTS/CAVEATS/IDEAS:
	none

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	EB	6/95		initial version
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
@method SerialDemoProcessClass, MSG_SERIAL_DEMO_OPEN_CLOSE_PORT
{
    /* If the serial port is open, then close it */
    if(serialPortOpen)
    {
	ChannelTearDown();
	MemFree(readBuffer);
	readBuffer = NullHandle;
    }
    else
    {
	/*
	 * Set up the serial port.  If setup fails, the don't do the
	 * rest of the setup stuff (like setting event notification).
	 */
	if( ChannelSetup())
	{
	    /*
	     * Allocate read buffer here rather than having to continually
	     * alloc/dealloc memory whenever a serial read event occurs.
	     */
	    if(NullHandle ==
	       (readBuffer = MemAlloc(SERIAL_DEMO_READ_BUFFER_SIZE,
					  HF_DYNAMIC, HAF_STANDARD)))
	    {
		/* Inform the user of the error and shutdown serial port */
		ReportError(ERR_CANT_ALLOCATE_MEMORY);
		ChannelTearDown();
	    }
	    else /* continue with serial opening stuff */
	    {
		ECCheckMemHandle(readBuffer);

		/*
		 * disable "set serial" settings menu so user can't
		 * muck with it while port it open
		 */
		@send SerialMainMenu::MSG_GEN_SET_NOT_ENABLED(
						VUM_DELAYED_VIA_APP_QUEUE);

		/*
		 * change trigger moniker to show it will disconnect
		 * These monikers are in the same block wiht the
		 * ConnectTrig.
		 */
		@call ConnectTrig::MSG_GEN_USE_VIS_MONIKER(OptrToChunk(@CloseConnection),
						VUM_DELAYED_VIA_APP_QUEUE);

		/*
		 * everything is okay, so enable the send trigger so that
		 * data can be sent
		 */
		@call SendDataTrig::MSG_GEN_SET_ENABLED(
						VUM_DELAYED_VIA_APP_QUEUE);

		/*
		 * set up serial notification event so we don't have to
		 * poll serial port.  the event will handle incoming
		 * data
		 */
		SetupSerialNotification();
	    }
	}
    }
}



/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		MSG_SERIAL_DEMO_SEND_TEXT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:	Send the contents of the send-buffer text obj.

PASS: 		Void.

RETURN:		void.

PSEUDO CODE/STRATEGY:
	Get the text to send from the input object
	Write the stuff to the serial port and report any errors
	Check to make sure all the bytes were sent.  If not, then
	  report an error.
	Free up the block that was created to hold the text

KNOWN DEFECTS/CAVEATS/IDEAS:
	none

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	EB	6/95		initial version
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
@method SerialDemoProcessClass, MSG_SERIAL_DEMO_SEND_TEXT
{
    MemHandle sendBuffer;
    byte *    sendPtr;
    word      buffSize;
    word      bytesWritten;

    /*
     * Use MSG_VIS_TEXT_GET_ALL_BLOCK instead of GET_ALL_PTR so that
     * we don't have to specifically allocate memory for the pointer
     */
    sendBuffer = @call SerialSendBufferDisplay::
			    MSG_VIS_TEXT_GET_ALL_BLOCK(NullHandle);
EC( ECCheckMemHandle(sendBuffer);				)

    /*
     * If the text object returned a NullHandle (probably because
     * there wasn't enough memory to allocate a block), then let
     * the user know and abort.  
     */
    if (sendBuffer == NullHandle)
    {
        ReportError(ERR_CANT_ALLOCATE_MEMORY);
    }
    else
    {

        sendPtr = MemLock(sendBuffer);

        /*
         * Check the amount of data to send.  If it is zero then there
         * is nothing to send to return out of this method.
         */
        if(0 == (buffSize = strlen((char*)sendPtr)))
        {
	    return;
        }

EC(     ECCheckDriverHandle(serialDriver);			)
        ReportError( SerialWrite(serialDriver, serialComPort, STREAM_BLOCK,
			     buffSize, sendPtr, &bytesWritten));

        if(buffSize != bytesWritten)
        {
	    ReportError(ERR_SEND_DATA_ERROR);
        }

        MemFree(sendBuffer);
    }
}



/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		SerialTextDisplayClass Methods
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		MSG_SERIAL_DEMO_READ_IN_SERIAL_DATA
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:	Read bytes from the communication channel and display them.

PASS: 		word        numAvail = cx
		StreamToken stream = dx
		StreamRoles side = bp

RETURN:		Void.

PSEUDO CODE/STRATEGY:
	This message is called via the SerialEventNotification mechanism
	so data must have arrived in the comm port.

	Check to make sure that the readBuffer exists.  If not, then error
	Otherwise read all the data from the serial port.
	Check for any serial or stream errors to report
	Scan thru the received data to make sure null bytes are in the block
	Append the text to the display text object.

KNOWN DEFECTS/CAVEATS/IDEAS:
	none

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	EB	9/95		Initial version
	NF	9/5/96		Corrected parameters

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
@method SerialTextDisplayClass, MSG_SERIAL_DEMO_READ_IN_SERIAL_DATA
{
    word   i;
    word   bytesRead	= 0;
    char * readBuffPtr	= NULL;
    word   errorFlag;

    /* Do we already have an allocated memory block? */
    if(NullHandle == readBuffer)
    {
	/* Inform the user of the error. */
	ReportError(ERR_DATA_BUT_NO_MEMORY);
    }
    else
    {
	ECCheckMemHandle(readBuffer);

	/* Lock down THE read buffer block. */
	readBuffPtr = MemLock(readBuffer);

	/*
	 * Now read from the port.  If any errors occur, then get the
	 * error and report it.
	 */
	if( SerialRead(serialDriver, serialComPort,
		       STREAM_NO_BLOCK,
		       SERIAL_DEMO_READ_BUFFER_SIZE,
		       (byte*)readBuffPtr, &bytesRead))
	{
	    /* Inform the user of the serial error. */
	    ReportError(ERR_SERIAL_READ);
	    StreamGetError(serialDriver, serialComPort,
			   STREAM_ROLES_READER, &errorFlag);
	    ReportSerialError(errorFlag);
	}

	/* if there is any data to play with, use it */
	if(bytesRead)
	{
	    /*
	     * First make sure to remove any nasty chars by replacing
	     * them with a space.  Need to do this because the call
             * to MSG_VIS_TEXT_APPEND_PTR specifies the length of the
             * text to append.  This will crash if there is a null
             * byte within the string.  (This whole test is mostly a
             * safety net for the unlikely case that a bad byte is 
             * picked up on the serial port.)
	     */
	    for (i=0; i<bytesRead; i++)
	    {
		/*
		 * make sure that there are no NULL chars in the
		 * text stream
		 */
		if(readBuffPtr[i] == (byte)0)
		    readBuffPtr[i] = (byte)C_SPACE; /* space */
	    }

	    /* now display any text data received */
	    @call SerialRcvBufferDisplay::MSG_VIS_TEXT_APPEND_PTR(
						 readBuffPtr, bytesRead);
	}
	MemUnlock(readBuffer);
    }
}	/* End of MSG_SERIAL_DEMO_READ_IN_SERIAL_DATA.	*/



/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%		All sorts of Cool Utility Routines               %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		ChannelSetup
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:	Build a communication channel.

CALLED BY:	Internal --	MSG_SERIAL_DEMO_CHOOSE_COM_PORT.

PASS:		word	comPort		= COM port to use.

RETURN:		Boolean (TRUE is setup was okay)

PSEUDO CODE/STRATEGY:
	Check to make sure that the serial driver is loaded
	If so, then get the serial settings from the GenItems
	Open the serial port (report any opening errors)
	If no errors then
	  setup the serial format and flowcontrol

KNOWN DEFECTS/CAVEATS/IDEAS:
	none

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	JDM	93.07.22	Initial version.
	EB	9/95		many modifications

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
static Boolean ChannelSetup( void )
{
    StreamError errorFlag;

    /* Is there a serial driver? */
    if(serialDriver != NullHandle)
    {
	/*
	 * first load the global variables with the settings from the
	 * genitem groups
	 */
	GetSerialSettings();

	errorFlag = SerialOpen(serialDriver, serialComPort,
			       STREAM_OPEN_TIMEOUT,
			       SERIAL_DEMO_READ_BUFFER_SIZE,
			       SERIAL_DEMO_WRITE_BUFFER_SIZE,
			       SERIAL_TIMEOUT);

	if(errorFlag)
	{
	    /* serialPortOpen is still FALSE */
	    ReportError(errorFlag);
	    ReportError(ERR_COULDNT_OPEN_PORT);
	}
	else
	{
	    serialPortOpen = TRUE;

	    /* Set up the channel's line format. */
	    SerialSetFormat(serialDriver, serialComPort,
			(serialLength << SERIAL_FORMAT_LENGTH_OFFSET) |
			(serialParity << SERIAL_FORMAT_PARITY_OFFSET) |
			(serialXStopBits << SERIAL_FORMAT_EXTRA_STOP_OFFSET),
			serialMode, serialBaudRate);

	    SerialSetFlowControl(serialDriver, serialComPort,
			      SFC_SOFTWARE,
			      0, /* don't initialize SerialModem */
			      0 /* don't init SerialModemStatus */);
	}
    }

    /* let previous routine know whether serialport was opened okay */
    return (serialPortOpen);

}	/* End of ChannelSetup().	*/



/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		ChannelTearDown
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:	Shutdown the current serial communication channel
		and change GS_ENABLE of concerned UI objects.

CALLED BY:	Internal --	MSG_SERIAL_DEMO_CLOSE_APPLICATION,
				MSG_SERIAL_DEMO_OPEN_CLOSE_PORT, &
				ChannelSetup.
PASS:		Void.

RETURN:		Void.

PSEUDO CODE/STRATEGY:
	Flush the serial port and close it.
	Set the UI to serial-closed settings.

KNOWN DEFECTS/CAVEATS/IDEAS:
	Requires:	All serial global variables properly set.
	Asserts:	serialPortOpen == FALSE.

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	JDM	93.07.22	Initial version.
	EB	7/16/95		add msg sending to update various UI objects

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
static void ChannelTearDown( void )
{
    /* Close the currently open port (if any).	*/
    if(serialPortOpen)
    {
	/* Flush both sides of the stream.	*/
	SerialFlush(serialDriver, serialComPort, STREAM_ROLES_BOTH);

	/* Actually close the port itself.	*/
	SerialClose(serialDriver, serialComPort, FALSE);
	serialPortOpen = FALSE;

	/* set serial settings menus usable since port is now closed */
	@call SerialMainMenu::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);

	/* Closing down port, so disable ability to send data */
	@call SendDataTrig::MSG_GEN_SET_NOT_ENABLED(
					VUM_DELAYED_VIA_APP_QUEUE);

	/*
	 * Since port is closed, change connect trigger's moniker back to
	 * "Open Connection"
	 */
	@call ConnectTrig::MSG_GEN_USE_VIS_MONIKER(
					OptrToChunk(@OpenConnection), 
					VUM_DELAYED_VIA_APP_QUEUE);
    }
}	/* End of ChannelTearDown().	*/



/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		DisableInvalidComPorts
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
DESCRIPTION:	Determine which com ports exist and disable the comport
		listings for those that do not.  We remove the comport
		listing by setting the specific GenItem to be NOT_ENABED.

		This type of thing is especially necessary for PDA
		products like the OmniGo, which only has two possible
		serial ports (the built in port (SERIAL_COM1) and a
		PCMCIA serial port (SERIAL_COM4)).

		If you want to check if a PCMCIA serial card has been
		removed, use DR_SERIAL_PORT_ABSENT (#define this to 28)
		and use DriverCallEntryPoint (see streamc.h and serialdr.def
		for parameters to set).

CALLED BY:	MSG_GEN_PROCESS_OPEN_APPLICATION

PASS:           void

RETURN:		void

PSEUDO CODE/STRATEGY:
	Check to see which serial ports are available and
	disable the UI for the rest.

KNOWN DEFECTS/CAVEATS/IDEAS:
	none

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	EB	9/95		Initial version.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
void DisableInvalidComPorts( void )
{
    word interruptLevel;
    Boolean portOpen;

    if (SerialStatPort(serialDriver, SERIAL_COM1,
		       &interruptLevel,
		       &portOpen))
    {
	@send Com1Setting::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    }

    if (SerialStatPort(serialDriver, SERIAL_COM2,
		       &interruptLevel,
		       &portOpen))
    {
	@send Com2Setting::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    }

    if (SerialStatPort(serialDriver, SERIAL_COM3,
		       &interruptLevel,
		       &portOpen))
    {
	@send Com3Setting::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    }

    if (SerialStatPort(serialDriver, SERIAL_COM4,
		       &interruptLevel,
		       &portOpen))
    {
	@send Com4Setting::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    }

}



/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		GetSerialSettings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
DESCRIPTION:	Get the settings from the serial settings item groups
		and store in global variables.  Since these are exclusive,
		there should always be one item set, but just in case, we
		check for GIGT_NONE.

CALLED BY:	ChannelSetup

PASS:		void

RETURN:		void

PSEUDO CODE/STRATEGY:
	Get the settings from the GenItems.  If the user has
	not selected anything, then use the default setting.

KNOWN DEFECTS/CAVEATS/IDEAS:
	none

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	EB	6/95		Initial version.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
static void GetSerialSettings( void )
{
    if((serialComPort = @call ComPortList::
	MSG_GEN_ITEM_GROUP_GET_SELECTION()) == (SerialUnit)GIGS_NONE)
    {
	serialComPort = SERIAL_DEMO_COM_PORT_DEFAULT;
    }

    if((serialBaudRate = @call BaudRateList::
	MSG_GEN_ITEM_GROUP_GET_SELECTION()) == (SerialBaud)GIGS_NONE)
    {
	serialBaudRate = SERIAL_DEMO_BAUD_RATE_DEFAULT;
    }

    if((serialLength = @call SerialLengthList::
	MSG_GEN_ITEM_GROUP_GET_SELECTION()) == (SerialLength)GIGS_NONE)
    {
	serialLength = SERIAL_DEMO_LENGTH_DEFAULT;
    }

    if((serialParity = @call ParityBitsList::
	MSG_GEN_ITEM_GROUP_GET_SELECTION()) == (SerialParity)GIGS_NONE)
    {
	serialParity = SERIAL_DEMO_PARITY_DEFAULT;
    }

    if((serialXStopBits = @call SerialXStopBitsList::
	MSG_GEN_ITEM_GROUP_GET_SELECTION()) == (SerialExtraStopBits)GIGS_NONE)
    {
	serialXStopBits = SERIAL_DEMO_XSTOP_BITS_DEFAULT;
    }

    if((serialMode = @call SerialModeList::
	MSG_GEN_ITEM_GROUP_GET_SELECTION()) == (SerialMode)GIGS_NONE)
    {
	serialMode = SERIAL_DEMO_MODE_DEFAULT;
    }

}



/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		SetupSerialNotification
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:	Tell the stream driver to send us notification message
		MSG_SERIAL_DEMO_READ_IN_SERIAL_DATA whenever
		STREAM_THRESHOLD bytes are received in the in-buffer.

CALLED BY:	MSG_SERIAL_DEMO_OPEN_CLOSE_PORT

PASS:		void

RETURN:		void

PSEUDO CODE/STRATEGY:
	Set up the serial notification message and
	the number of bytes to receive in the serial
	buffer before sending the notification message.

KNOWN DEFECTS/CAVEATS/IDEAS:
	none

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	EB	6/95		Initial version.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
static void SetupSerialNotification( void )
{
    StreamNotifyType type;

    /*
     * set up StreamNotifyType for StreamReader, data event notification
     * (STREAM_EVENT_DATA), and notification mode by a message
     */
    type = ((1 << STREAM_TYPE_READER_OFFSET) |
	    (STREAM_EVENT_DATA << STREAM_TYPE_EVENT_OFFSET) |
	    (STREAM_MODE_MESSAGE << STREAM_TYPE_HOW_OFFSET));

    StreamSetMessageNotify(serialDriver, serialComPort, type,
			   MSG_SERIAL_DEMO_READ_IN_SERIAL_DATA,
			   @SerialRcvBufferDisplay);

    /*
     * Set the threshold for notification
     */
    StreamSetThreshold(serialDriver, serialComPort, STREAM_ROLES_READER,
		       STREAM_THRESHOLD);
    /*
     * STREAM_THRESHOLD is the number of bytes to buffer before
     * sending a notification event
     */
}



/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		ReportError
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:	Report an error

CALLED BY:	Internal

PASS:		word	error number

RETURN:		void

PSEUDO CODE/STRATEGY:
	Lock down the error string chunk array, reference the 
	specific error and display it in the error text object.

KNOWN DEFECTS/CAVEATS/IDEAS:
	none

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	EB	6/95		Initial version.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
static void ReportError(word errorNum)
{
    char *errorString;
    word size;

    /* If there is no error, then let's get outta here. */
    if(!errorNum)
       return;

    /* Figure out which error string to print out */
    MemLock(HandleOf(@ErrorStringArray));
EC( ECCheckChunkArray(@ErrorStringArray);			)

    errorString = ChunkArrayElementToPtr(@ErrorStringArray, errorNum, &size);

    @call SerialErrorDisplay::MSG_VIS_TEXT_APPEND_PTR((char *)errorString, 0);

    MemUnlock(HandleOf(@ErrorStringArray));
}



/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		ReportSerialError
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:	Report a SerialError

CALLED BY:	Internal (MSG_SERIAL_DEMO_READ_IN_SERIAL_DATA)

PASS:		word	serialError

RETURN:		void

PSEUDO CODE/STRATEGY:
	Check to see which error bit is set and report that error

KNOWN DEFECTS/CAVEATS/IDEAS:
	none

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	Doug	1/27/94		Initial version.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
static void ReportSerialError (word serialError)
{
	optr	errorString;
	word	unknownError = 0;
	char	hexString[50];
	int	i;

	for (i = 1; i != 0; i<<=1) {

	    /* Only set bits represent errors */
	    if (serialError & i) {

		    /* Figure out which error string to print out */
		    switch	(i) {
			case 1<<1:	errorString = @SerialErrorBit1;
					break;
			case 1<<2:	errorString = @SerialErrorBit2;
					break;
			case 1<<3:	errorString = @SerialErrorBit3;
					break;
			case 1<<4:	errorString = @SerialErrorBit4;
					break;
			default:	errorString = 0;
					unknownError += i;
					break;
		    }
		    if (errorString) {
			/* Inform the user of the serial error.	*/
			@call SerialErrorDisplay::MSG_VIS_TEXT_APPEND_OPTR
							(errorString, 0);
		    }
	    }
	}

	if (unknownError) {
	    sprintf	(hexString, "Unknown Serial Error(s):  %04xh\r",
			unknownError);
	    @call SerialErrorDisplay::MSG_VIS_TEXT_APPEND_PTR
			(hexString, 32);
	}
}
