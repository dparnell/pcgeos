
/**************************************************************
 *  ==CONFIDENTIAL INFORMATION==
 *  COPYRIGHT 1994-2000 BREADBOX COMPUTER COMPANY --
 *  ALL RIGHTS RESERVED  --
 *  THE FOLLOWING CONFIDENTIAL INFORMATION IS BEING DISCLOSED TO YOU UNDER A
 *  NON-DISCLOSURE AGREEMENT AND MAY NOT BE DISCLOSED OR FORWARDED BY THE
 *  RECIPIENT TO ANY OTHER PERSON OR ENTITY NOT COVERED BY THE SAME
 *  NON-DISCLOSURE AGREEMENT COVERING THE RECIPIENT. USE OF THE FOLLOWING
 *  CONFIDENTIAL INFORMATION IS RESTRICTED TO THE TERMS OF THE NON-DISCLOSURE
 *  AGREEMENT.
 **************************************************************/

/*
 **************************************************************************
 *  FILE:			fnctns.goc
 *  PROJECT:		GPC Banker
 *  DESCRIPTION:	This file has the various functions
 *			
 **************************************************************************
 */
/*
 ***************************************************************************
 *		Include files
 ***************************************************************************
 */

@include "bnkr30.goh"
@include "externs.goh"

 /***********************************************************************
 *
 * FUNCTION:	EnterTransaction
 *
 * CALLED BY:	MSG_ENTER_TRANS, MSG_ENTER_MULTICAT, MSG_IMPORT_QIF,
 *
 * STRATEGY:    
 *		
 *
 ***********************************************************************/
FloatNum EnterTransaction(
			  Boolean import,
			  FloatNum amount,
			  word year,
			  byte month,
			  byte day,
			  dword chkNum,
			  char payee[ENTRY_SIZE],
			  char memo[ENTRY_SIZE],
			  char cat[ENTRY_SIZE],
			  Boolean tax,
			  Boolean cleared,
			  DBItem	*transItem)
{
 AcctStruct		*account;
 TransStruct		*trans;
 DBItem		transItemNum, multiTrans, prevMultiTrans;
 DBGroup		acctgroup, multiGroup;
 DBGroupAndItem	mapitem;
 DBMapStruct*	mapPtr;
 FloatNum		balance;
 TempMultiStruct	*arrayElement;
 word		i;
 char		payTempStr[ENTRY_SIZE+3];


    /* Do our standard setup */
	FLOAT_SET_FLOATNUM_TO_0(balance);
    mapitem = DBGetMap(GPCBnkrFile);
    mapPtr = DBLockUngrouped(GPCBnkrFile, mapitem);
    account = (AcctStruct *) (mapPtr + sizeof(DBMapStruct));

    /* Get the account's DBGroup */
    acctgroup = account[currentAcct].AS_group;

    /* Add the new trans to the head of the list since the bulk
     * of the activity is going to be with the newest
     * transactions
     */

    /* create the new trans DBItem */
    transItemNum = DBAlloc(GPCBnkrFile, acctgroup, sizeof(TransStruct));
    /* check for no more room */
    if (!transItemNum)   {
	  NotifyDBox(0, @NoRoomMsg);
	  return balance;
	  }

    /* fill in the return value */
    *transItem = transItemNum;

    /* Increase the number of transactions */
    account[currentAcct].AS_numTrans++;
    numTrans++;

    if ((currentType == TRANS_CK)/* && !multiFlag*/ && !import && autoNum)  {
	  /* so put in next number */
	  account[currentAcct].AS_nextNum = chkNum + 1;
	  }

    /* and update the balance */
    if ((currentType == TRANS_CK) || (currentType == TRANS_DB)
	    || (currentType == TRANS_XFM))  {
	  /* sub check/debit amount */
	  FloatPushNumber(&account[currentAcct].AS_balance);
	  FloatPushNumber(&amount);
	  FloatSub();
	  FloatPopNumber(&balance);
	  }
    else  {  /* add deposit/credit amount */
	  FloatPushNumber(&account[currentAcct].AS_balance);
	  FloatPushNumber(&amount);
	  FloatAdd();
	  FloatPopNumber(&balance);
	  }
    account[currentAcct].AS_balance = balance;

    /* Mark the map item as dirty */
    DBDirty(mapPtr);
    DBUnlock(mapPtr);

    /* Lock new transaction DBItem */
    trans = DBLock(GPCBnkrFile, acctgroup, transItemNum);

    /* put transaction info into database*/
    strcpy(trans->TS_payee, payee);
    strcpy(trans->TS_memo, memo);
    strcpy(trans->TS_category, cat);
    trans->TS_year = year;
    trans->TS_month = month;
    trans->TS_day = day;
    trans->TS_number = chkNum;
    trans->TS_amount = amount;
    trans->TS_taxItem = tax;
    trans->TS_cleared = cleared;
    trans->TS_type = currentType;
    if (multiFlag)  {
	  trans->TS_numMultis = numMultis;
	  }
	 else  {
	  trans->TS_numMultis = 0;
	  }
    trans->TS_multiOf = 0;

    /* Mark the trans item as dirty and unlock it. */
    DBDirty(trans);
    DBUnlock(trans);

    if (multiFlag)  {
	  /* Create this trans' multis DB group */
	  multiGroup = DBGroupAlloc(GPCBnkrFile);
	  /* put the M/ in front of payee to indicate multi */
	  MemLock (OptrToHandle(@MPayPrefix));
	  strcpy (payTempStr, LMemDeref(@MPayPrefix));
	  MemUnlock (OptrToHandle(@MPayPrefix));
	  strcat (payTempStr, payee);
	  /* make sure new string isn't too long */
	  if (strlen(payTempStr) > (ENTRY_SIZE - 1))  {
		/* truncate it */
		payTempStr[ENTRY_SIZE - 1] = '\0';
		}

	  /* add the multis to the dbgroup but not to the sort list */
	  for (i = 0; i < numMultis; i++)  {
		/* create the new trans DBItem */
		multiTrans = DBAlloc(GPCBnkrFile, multiGroup, sizeof(TransStruct));
		if (i == 0)  {
		   /* put the pointer to this item in the parent */
		   trans = DBLock(GPCBnkrFile, currentAcctGroup, transItemNum);
		   trans->TS_multiGroup = multiGroup;
		   }
		else  {
		   /* put the pointer to this item in the previous multi */
		   trans = DBLock(GPCBnkrFile, multiGroup, prevMultiTrans);
		   }
		trans->TS_multiItem = multiTrans;
		DBDirty(trans);
		DBUnlock(trans);

		/* get the info from the temp array */
		MemLock(multiHeapHandle);
		arrayElement = ChunkArrayElementToPtrHandles(
					multiHeapHandle,
					multiChunkArray,
					i,
					0);

		/* Lock new transaction DBItem */
		trans = DBLock(GPCBnkrFile, multiGroup, multiTrans);

		/* put transaction info into database*/
		strcpy(trans->TS_memo, arrayElement->TMS_note);
		strcpy(trans->TS_category, arrayElement->TMS_cat);
		trans->TS_amount = arrayElement->TMS_amount;
		MemUnlock(multiHeapHandle);

		strcpy(trans->TS_payee, payTempStr);
		trans->TS_year = year;
		trans->TS_month = month;
		trans->TS_day = day;
		trans->TS_number = chkNum;
		trans->TS_taxItem = FALSE;
		trans->TS_cleared = FALSE;
          trans->TS_type = currentType;
		trans->TS_multiGroup = 0;
		trans->TS_multiItem = 0;
		trans->TS_multiOf = transItemNum;

		prevMultiTrans = multiTrans;
		/* Mark the trans item as dirty and unlock it. */
  		DBDirty(trans);
		DBUnlock(trans);
		} /* end of loop thru multis for */
	  }  /* end of multiFlag if */

    return(balance);

}


/***********************************************************************
 *
 * FUNCTION:	TransIndexInsert
 *
 * CALLED BY:	MSG_ENTER_TRANS, MSG_ENTER_MULTICAT, MSG_ENTER_XFER
 *              MSG_IMPORT_QIF, MSG_RECONCILE_DONE
 *
 * STRATEGY:   puts transactions into sort array
 *             returns the position where the trans was inserted
 *
 ***********************************************************************/
word TransIndexInsert(dword transDateNum,
			 TimerDateAndTime date,
			 dword chkNum,
			 FloatNum amount,
			 Boolean isCleared,
			 DBItem transItem)
{
 word			i, insertedAt;
 TransSortStruct	*trArrayElement, *trInsertElement;
 MemHandle		mh;
 dword			arrayDateNum;
 int				testType;


    /* get the sort list */
    transListVMBHandle = VMFind(GPCBnkrFile, NullHandle, (currentAcct*10)+ALLSORT);
    VMLock(GPCBnkrFile, transListVMBHandle, &mh);
    for (i = 0; i < numTrans - 1; i++)  {
	  /* Get the ith element */
	  trArrayElement = ChunkArrayElementToPtrHandles(
				    mh,
				    transListChunkArray,
				    i,
				    0);
	  /* convert date to comparison number */
       arrayDateNum = ((dword)(trArrayElement->TSS_year) * (dword)10000) +
		   ((dword)(trArrayElement->TSS_month) * (dword)100) +
		    (dword)trArrayElement->TSS_day;
	  testType = trArrayElement->TSS_type;
       /* is this trans' date < one in ith element? */
	  if (transDateNum < arrayDateNum)  { /* yes */
		/* put the new transaction in here */
		trInsertElement = ChunkArrayInsertAtHandle(
				transListChunkArray,
				trArrayElement,
				0);
		trInsertElement->TSS_type = currentType;
		trInsertElement->TSS_ckNumber = chkNum;
		trInsertElement->TSS_year = date.TDAT_year;
		trInsertElement->TSS_month = (byte) date.TDAT_month;
		trInsertElement->TSS_day = (byte) date.TDAT_day;
		trInsertElement->TSS_item = transItem;
		trInsertElement->TSS_cleared = isCleared;
		trInsertElement->TSS_toClear = FALSE;
		/* get out of loop by... */
		insertedAt = i;
		i = numTrans;
		}  /* end of < date if */
	  /* is this trans' date == one in ith element? */
	  if (transDateNum == arrayDateNum)  { /* yes */
		/* is this type != the ith element's type */
		if ((currentType != testType) &&
				 ((currentType == TRANS_CR) ||
				 ((currentType == TRANS_DP) && (testType != TRANS_CR)) ||
				 ((currentType == TRANS_XFP) && ((testType == TRANS_DB) ||
					(testType == TRANS_XFM) || (testType == TRANS_CK))) ||
				 ((currentType == TRANS_DB) && ((testType == TRANS_XFM) ||
					(testType == TRANS_CK))) ||
				 ((currentType == TRANS_XFM) && (testType == TRANS_CK))))  {
			/* Order: credits, deposits, xfer-in, debits, xfer-out, check */
			/* put the new transaction in here */
		   trInsertElement = ChunkArrayInsertAtHandle(
				transListChunkArray,
		          trArrayElement,
				0);
		   trInsertElement->TSS_type = currentType;
		   trInsertElement->TSS_ckNumber = chkNum;
		   trInsertElement->TSS_year = date.TDAT_year;
		   trInsertElement->TSS_month = (byte) date.TDAT_month;
		   trInsertElement->TSS_day = (byte) date.TDAT_day;
		   trInsertElement->TSS_item = transItem;
		   trInsertElement->TSS_cleared = isCleared;
		   trInsertElement->TSS_toClear = FALSE;
		   /* get out of loop by... */
		   insertedAt = i;
		   i = numTrans;
		   }  /* end of != type if */
		/* is this type == the ith element's type */
		if (currentType == testType)  { /* yes */
		   /* is it a lower # ck or trans !check? */
		   if ((currentType == TRANS_CK)
				&& (chkNum <= trArrayElement->TSS_ckNumber)) {  /* yes */
			 /* put the new transaction in here */
			 trInsertElement = ChunkArrayInsertAtHandle(
						    transListChunkArray,
						    trArrayElement,
						    0);
			 trInsertElement->TSS_type = currentType;
			 trInsertElement->TSS_ckNumber = chkNum;
			 trInsertElement->TSS_year = date.TDAT_year;
			 trInsertElement->TSS_month = (byte) date.TDAT_month;
			 trInsertElement->TSS_day = (byte) date.TDAT_day;
			 trInsertElement->TSS_item = transItem;
			 trInsertElement->TSS_cleared = isCleared;
			 trInsertElement->TSS_toClear = FALSE;
			 /* get out of loop by... */
			 insertedAt = i;
			 i = numTrans;
			 }  /* end of <= ckNum if */
		   }  /* end of == type if */
		}  /* end of == date if */
	  }  /* end of for loop */
    if (i != numTrans + 1)  {  /* then we didn't put it in yet...
				* that means it is either the only
				* trans to enter so far, or the latest
				* date.  In either case, just append
				* it to the array.
				*/
	  trArrayElement = ChunkArrayAppendHandles(
			 mh,
		      transListChunkArray,
			 0);
	  trArrayElement->TSS_type = currentType;
	  trArrayElement->TSS_ckNumber = chkNum;
	  trArrayElement->TSS_year = date.TDAT_year;
	  trArrayElement->TSS_month = (byte) date.TDAT_month;
	  trArrayElement->TSS_day = (byte) date.TDAT_day;
	  trArrayElement->TSS_item = transItem;
	  trArrayElement->TSS_cleared = isCleared;
	  insertedAt = numTrans - 1;
	  } /* end of append it if */
    VMDirty(mh);
    VMUnlock(mh);

    /* now we have to adjust the running balance(s) */
    TransIndexAdjRunBal(insertedAt, amount);

    return(insertedAt);

}

/***********************************************************************
 *
 * FUNCTION:	TransIndexAdjRunBal (word insertedAt, FloatNum amount)
 *
 * CALLED BY:
 *
 *
 * STRATEGY:   given the insertion point and the amount of the trans
 *			just added/changed adjusts all remaining run bals
 *
 *
 ***********************************************************************/
void TransIndexAdjRunBal(word insertedAt, FloatNum amount)
{
 word			i;
 TransSortStruct	*trArrayElement;
 MemHandle		mh;
 FloatNum			balance;


    /* get the sort list */
    transListVMBHandle = VMFind(GPCBnkrFile, NullHandle, (currentAcct*10)+ALLSORT);
    VMLock(GPCBnkrFile, transListVMBHandle, &mh);

    /* first see if there is only 1 transaction */
    if (numTrans == 1)  {
	  trArrayElement = ChunkArrayElementToPtrHandles(
				    mh,
				    transListChunkArray,
				    0,
				    0);
	  FLOAT_SET_FLOATNUM_TO_0(balance);
	  if ((currentType == TRANS_CK) || (currentType == TRANS_DB)
			|| (currentType == TRANS_XFM))  {
		/* sub check/debit amount */
		FloatPushNumber(&balance);
		FloatPushNumber(&amount);
		FloatSub();
		FloatPopNumber(&trArrayElement->TSS_runBal);
		}
	  else  {  /* add deposit/credit amount */
	    FloatPushNumber(&balance);
		FloatPushNumber(&amount);
		FloatAdd();
		FloatPopNumber(&trArrayElement->TSS_runBal);
		}

	  }
    else  { /* more than one */
	  if (insertedAt == 0) {
		/* take care of this tranaction */
		trArrayElement = ChunkArrayElementToPtrHandles(
				    mh,
				    transListChunkArray,
				    insertedAt,
				    0);
		}
	  else {
		/* first get the previous balance */
		trArrayElement = ChunkArrayElementToPtrHandles(
				    mh,
				    transListChunkArray,
				    insertedAt - 1,
				    0);
		balance = trArrayElement->TSS_runBal;
		/* now take care of this tranaction */
	     trArrayElement = ChunkArrayElementToPtrHandles(
				    mh,
				    transListChunkArray,
				    insertedAt,
				    0);
		}
	  if ((currentType == TRANS_CK) || (currentType == TRANS_DB)
			|| (currentType == TRANS_XFM))  {
		/* sub check/debit amount */
		FloatPushNumber(&balance);
		FloatPushNumber(&amount);
		FloatSub();
		FloatPopNumber(&trArrayElement->TSS_runBal);
		}
	  else  {  /* add deposit/credit amount */
	    FloatPushNumber(&balance);
		FloatPushNumber(&amount);
		FloatAdd();
		FloatPopNumber(&trArrayElement->TSS_runBal);
		}
	  /* and now all the later transactions */
	  for (i = (insertedAt + 1); i < numTrans; i++)  {
		trArrayElement = ChunkArrayElementToPtrHandles(
				    mh,
				    transListChunkArray,
				    i,
				    0);
		/* and update the balance */
		if ((currentType == TRANS_CK) || (currentType == TRANS_DB)
			|| (currentType == TRANS_XFM))  {
		   /* sub check/debit amount */
		   FloatPushNumber(&trArrayElement->TSS_runBal);
		   FloatPushNumber(&amount);
		   FloatSub();
		   FloatPopNumber(&trArrayElement->TSS_runBal);
		   }
		else  {  /* add deposit/credit amount */
		   FloatPushNumber(&trArrayElement->TSS_runBal);
		   FloatPushNumber(&amount);
		   FloatAdd();
		   FloatPopNumber(&trArrayElement->TSS_runBal);
		   }
		} /* end of later transactions for loop */
	  }  /* end of more than one trans else */
    VMDirty(mh);
    VMUnlock(mh);

    return;

}

/***********************************************************************
 *
 * FUNCTION:	TransIndexDelete
 *
 * CALLED BY:	MSG_DELETE_TRANS
 *
 * STRATEGY:
 *
 *
 ***********************************************************************/
void TransIndexDelete(word index)
{
TransSortStruct	*trArrayElement;
MemHandle			mh;


    transListVMBHandle = VMFind(GPCBnkrFile, NullHandle, (currentAcct*10)+ALLSORT);
    VMLock(GPCBnkrFile, transListVMBHandle ,&mh);
    /* get the element address */
    trArrayElement = ChunkArrayElementToPtrHandles(
				 mh,
				 transListChunkArray,
				 index,
				 0);
    /* delete it */
    ChunkArrayDeleteHandle(transListChunkArray, trArrayElement);
    VMDirty(mh);
    VMUnlock(mh);

}

/***********************************************************************
 *
 * FUNCTION:	DateCheck
 *
 * CALLED BY:	
 *
 * STRATEGY:    
 *		
 *
 ***********************************************************************/
 Boolean DateCheck(char dateString[12])
 {
 TimerDateAndTime	date;
 word		daysInMonth;
 Boolean		isValid, isGood;


    /* parse the date string */
    isValid = LocalParseDateTime(dateString, DTF_SHORT, &date);

    /* check for # of days in month */
    daysInMonth = LocalCalcDaysInMonth(date.TDAT_year, date.TDAT_month);

    /* is it a good date? */
    if((isValid == -1) && ((date.TDAT_day) <= daysInMonth)) {
       isGood = TRUE;
       }
     else  {
	  isGood = FALSE;
	  NotifyDBox(0, @BadDateMsg);
       }
    return (isGood);
}


/***********************************************************************
 *
 * FUNCTION:	CatThere
 *
 * CALLED BY:  CheckIsNewCat, MSG_MODIFY_CATEGORY
 *
 *
 * STRATEGY:   returns FALSE if new TRUE if not
 *
 *
 ***********************************************************************/
Boolean CatThere(char catString[ENTRY_SIZE])
{
 MemHandle		mh;
 CatPickStruct		*pickElement;
 word			length, i;
 Boolean			isDupe = FALSE;


    /* first see if the new cat name is "Multiples"
	* if so don't worry about it, just return TRUE */
    MemLock (OptrToHandle(@AcctSP));
    if (!strcmp(LMemDeref(@MultCatText), catString)) {
	  MemUnlock (OptrToHandle(@AcctSP));
	  return (TRUE);
	  }
    MemUnlock (OptrToHandle(@AcctSP));

    /* see if it is in the list */
    catListVMBHandle = VMFind(GPCBnkrFile, NullHandle, CATLIST);
    VMLock(GPCBnkrFile, catListVMBHandle ,&mh);
    for (i = 0; i < catNumItems; i++)  {
	  /* Get the ith element */
	  pickElement = ChunkArrayElementToPtrHandles(
		   mh,
		   catListChunkArray,
		   i,
		   0);
	  /* get the longer */
	  if (strlen(pickElement->CPS_category) >= strlen(catString))
		  length = strlen(pickElement->CPS_category);
	  else  length = strlen(catString);
	  /* OK - is it the same? */
	  if (!LocalCmpStringsNoCase(catString, pickElement->CPS_category, length)) {
		/* we've found a match of cat */
		isDupe = TRUE;
		i = catNumItems;
		}
	  }  /* end of for loop */
    VMUnlock(mh);

    return(isDupe);
 }


/***********************************************************************
 *
 * FUNCTION:	CheckIsNewCat
 *
 * CALLED BY:  MSG_ENTER_TRANS, MSG_MODIFY_TRANS, MSG_NEW_PAYEE,
 *             MSG_MODIFY_PAYEE
 *
 * STRATEGY:   returns FALSE if user wants to stop the process and
 *		     go back to the calling dialog box
 *
 ***********************************************************************/

Boolean CheckIsNewCat(char catString[ENTRY_SIZE])
{
 Boolean			parentDupe, subDupe;
 Boolean			subCat = FALSE;
 word			i, colonPos, catType;
 char			INCString[ENTRY_SIZE + 150];
 char			subCatString[CAT_SIZE];
 char			parentCatString[CAT_SIZE];
 InteractionCommand	catAnswer;


    /* see if we have subcat */
    for (i = 0; i < strlen(catString); i++)  {
	  if (catString[i] == ':') subCat = TRUE;
	  if (subCat) {
		colonPos = i;
		i = strlen(catString);
		}
	  }
    /* if we do, separate into parent and sub */
    if (subCat)  {
	  catString[colonPos] = NULL;
	  strcpy(parentCatString, catString);
	  strcpy(subCatString, &catString[colonPos + 1]);
	  /* restore the string that was sent into the function */
	  catString[colonPos] = ':';
	  }
    else  {
	  strcpy(parentCatString, catString);
	  subCatString[0] = 0;
	  }
    /* see if either is a dupe - FALSE means New */
    parentDupe = CatThere(parentCatString);
    subDupe = TRUE;
    if (subCatString[0]) subDupe = CatThere(subCatString);

    if (!parentDupe || !subDupe)  {  /* one or both are new */
	  /* set up the dbox text */
	  MemLock (OptrToHandle(@INCMsg1));
	  strcpy(INCString, LMemDeref(@INCMsg1));
	  strcat(INCString, catString);
	  strcat(INCString, LMemDeref(@INCMsg2));
	  MemUnlock (OptrToHandle(@INCMsg1));
	  @call INCText::MSG_VIS_TEXT_REPLACE_ALL_PTR(INCString, 0);
	  /* ask if user wants to add */
	  catAnswer = UserDoDialog(@IsNewCatDBox);
	  if (catAnswer == IC_YES) {
		/* add one or both defaulting to Expenses */
		if ((currentType == TRANS_CR) || (currentType == TRANS_DP)
			|| (currentType == TRANS_XFP)) catType = CTYPE_INC;
		else catType = CTYPE_EXP;
		if (!parentDupe)  {
		   AddCatCheck(parentCatString, "", catType);
		   AddCatOK();
		   }
		if (!subDupe)  {
		   AddCatCheck(subCatString, parentCatString, catType);
		   AddCatOK();
		   }
		return (TRUE);
		}
	  if (catAnswer == IC_NO) {
		/* do nothing - just keep on */
		return (TRUE);
		}
	    else  {
		/* it was cancel */
		return (FALSE);
		}
	  }  /* end of its new if */

    else  {  /* it's already on the list */
	  return (TRUE);
	  }

}

/***********************************************************************
 *
 * FUNCTION:	AddCatCheck
 *
 * CALLED BY:	MSG_NEW_CATEGORY,  MSG_IMPORT_QIF
 *
 * STRATEGY:    
 *		
 *
 ***********************************************************************/
Boolean AddCatCheck(char catString[ENTRY_SIZE],
				char parentString[CAT_SIZE],
				word classification)
{
MemHandle		mh;
CatPickStruct	*pickElement, *pickInsertElement;
CatPickStruct	*pickSubElement, *pickNextElement;
char           testString[ENTRY_SIZE];
word			length, i, j, numSubs, testType, numIncs;
word			addStart, addEnd;
Boolean		isDupe = FALSE;
Boolean		inserted = FALSE;


    /* get cat list's block using its ID # */
    catListVMBHandle = VMFind(GPCBnkrFile, NullHandle, CATLIST);
    VMLock(GPCBnkrFile, catListVMBHandle ,&mh);

    /* count the income items */
    i = 0;
    testType = CTYPE_INC;
    while (testType == CTYPE_INC)   {
	  pickElement = ChunkArrayElementToPtrHandles(
								mh,
								catListChunkArray,
								i,
								0);
	  testType = pickElement->CPS_type;
	  if (testType == CTYPE_EXP)  numIncs = i;
	  i++;
	  }

    /* set the start and end points */
    if (classification == CTYPE_INC)  {
	  addStart = 1; /* don't check "Income:" item */
	  addEnd = numIncs;
	  }
    else if (classification == CTYPE_EXP) {
	  addStart = numIncs + 1;  /* don't check "Expense:" item */
	  addEnd = catNumItems;
	  }
    else {  /* type is unspecified */
	  addStart = 1;
	  addEnd = catNumItems;
	  }


	 /* now insert the cat */
	 if (!parentString[0])  { /* just a cat */
		 for (i = addStart; i < addEnd; i++)  {
			 pickElement = ChunkArrayElementToPtrHandles(
								mh,
								catListChunkArray,
								i,
								0);
			 if (!pickElement->CPS_isSub) {
				 strcpy(testString, pickElement->CPS_category);
				 /* get the longer */
				 if (strlen(testString) >= strlen(catString))
					 length = strlen(testString);
				 else  length = strlen(catString);
				 /* is this cat before one in ith element? */
				 if (LocalCmpStringsNoCase(catString, testString, length) < 0)  { /* yes */
					 /* put the new cat in here */
					 pickInsertElement = ChunkArrayInsertAtHandle(
										  catListChunkArray,
										  pickElement,
										  0);
					 strcpy(pickInsertElement->CPS_category, catString);
					 strcpy(pickInsertElement->CPS_subOf, "");
					 pickInsertElement->CPS_type = classification;
					 pickInsertElement->CPS_numSubs = 0;
					 pickInsertElement->CPS_isSub = FALSE;
					 pickInsertElement->CPS_isSelected = FALSE;
					 currentCat = i;
					 /* get out of loop by... */
					 i = addEnd;
					 inserted = TRUE;
					 }  /* end of before? if */
				 /* OK - is it the same? */
				 if (!LocalCmpStringsNoCase(catString, testString, length))  { /* yes */
					 isDupe = TRUE;
					 /* get out of loop by... */
					 i = addEnd;
					 inserted = TRUE;
					 }  /* end of same? if */
				 } /* end of its not a sub if */
			 }  /* end of for loop */
		 /* check to see if we inserted it */
		 if (!inserted && (classification == CTYPE_EXP))  {
			 /* append it to the array */
			 pickElement = ChunkArrayAppendHandles(
							mh,
							catListChunkArray,
							0);
			 strcpy(pickElement->CPS_category, catString);
			 strcpy(pickElement->CPS_subOf, "");
			 pickElement->CPS_type = classification;
			 pickElement->CPS_numSubs = 0;
			 pickElement->CPS_isSub = FALSE;
			 pickElement->CPS_isSelected = FALSE;
			 currentCat = catNumItems;
			 } /* end of append it if */
		 if (!inserted && (classification == CTYPE_INC))  {
			 /* insert it at end of income items */
			 pickElement = ChunkArrayElementToPtrHandles(
								mh,
								catListChunkArray,
								addEnd,
								0);
			 pickInsertElement = ChunkArrayInsertAtHandle(
										  catListChunkArray,
										  pickElement,
										  0);
			 strcpy(pickInsertElement->CPS_category, catString);
			 strcpy(pickInsertElement->CPS_subOf, "");
			 pickInsertElement->CPS_type = classification;
			 pickInsertElement->CPS_numSubs = 0;
			 pickInsertElement->CPS_isSub = FALSE;
			 pickInsertElement->CPS_isSelected = FALSE;
			 currentCat = addEnd;
			 } /* end of insert INC if */
		 }  /* end of just a cat if */

	 else  { /* we're entering a sub-cat */
		 /* find the parent */
		 for (i = 0; i < catNumItems; i++)  {
			 pickElement = ChunkArrayElementToPtrHandles(
								mh,
								catListChunkArray,
								i,
								0);
			 strcpy(testString, pickElement->CPS_category);
			 /* get the longer */
			 if (strlen(testString) >= strlen(parentString))
				 length = strlen(testString);
			 else  length = strlen(parentString);
			 /* is this it? */
			 if (!LocalCmpStringsNoCase(parentString, testString, length))  { /* yes */
				 numSubs = pickElement->CPS_numSubs;
				 /* insert it in alpha order after the parent */
				 for (j = 0; j < numSubs; j++)  {
					 pickSubElement = ChunkArrayElementToPtrHandles(
											mh,
											catListChunkArray,
											i + j + 1,
											0);
					 strcpy(testString, pickSubElement->CPS_category);
					 /* get the longer */
					 if (strlen(testString) >= strlen(catString))
						 length = strlen(testString);
					 else  length = strlen(catString);
					 /* is this sub-cat before one in jth element? */
					 if (LocalCmpStringsNoCase(catString, testString, length) < 0)  { /* yes */
						 /* put the new cat in here */
						 pickInsertElement = ChunkArrayInsertAtHandle(
													catListChunkArray,
													pickSubElement,
													0);
						 strcpy(pickInsertElement->CPS_category, catString);
						 strcpy(pickInsertElement->CPS_subOf, parentString);
						 pickInsertElement->CPS_type = classification;
						 pickInsertElement->CPS_numSubs = 0;
						 pickInsertElement->CPS_isSub = TRUE;
						 pickInsertElement->CPS_isSelected = FALSE;
						 /* get out of loop by... */
						 j = numSubs;
						 inserted = TRUE;
						 }  /* end of before? if */
					 /* OK - is it the same? */
					 if (!LocalCmpStringsNoCase(catString, testString, length))  { /* yes */
						 isDupe = TRUE;
						 /* get out of loop by... */
						 j = numSubs;
						 inserted = TRUE;
						 }  /* end of same? if */
					 }  /* end of insert it after parent for (j) loop */
				 /* check to see if we inserted it */
				 if (!inserted)  {  /* not inserted yet */
					 /* make sure we're not at the end of the cat array */
					 if ((i + numSubs + 1) < catNumItems)  {
						 /* get the next parent cat */
						 pickNextElement = ChunkArrayElementToPtrHandles(
												 mh,
												 catListChunkArray,
												 i + numSubs + 1,
												 0);
						 /* now insert our sub */
						 pickSubElement = ChunkArrayInsertAtHandle(
												catListChunkArray,
												pickNextElement,
												0);
						 strcpy(pickSubElement->CPS_category, catString);
						 strcpy(pickSubElement->CPS_subOf, parentString);
						 pickSubElement->CPS_type = classification;
						 pickSubElement->CPS_numSubs = 0;
						 pickSubElement->CPS_isSub = TRUE;
						 pickSubElement->CPS_isSelected = FALSE;
						 } /* end of insert it before the next parent if */
					 else  {  /* append it */
						 pickElement = ChunkArrayAppendHandles(
											mh,
											catListChunkArray,
											0);
						 strcpy(pickElement->CPS_category, catString);
						 strcpy(pickElement->CPS_subOf, parentString);
						 pickElement->CPS_type = classification;
						 pickElement->CPS_numSubs = 0;
						 pickElement->CPS_isSub = TRUE;
						 pickElement->CPS_isSelected = FALSE;
						 } /* end of append it else */
					 }  /* end of not inserted yet if */
				 /* increment parent's sub counter */
				 pickElement = ChunkArrayElementToPtrHandles(
									mh,
									catListChunkArray,
									i,
									0);
				 (pickElement->CPS_numSubs)++;
				 /* bail out of the loop */
				 i = catNumItems;
				 }  /* end of found our parent if */
			 }  /* end of find the parent for (i) loop */
	    }  /* end of entering a sub-cat else */

    /* unlock the array */
    VMDirty(mh);
    VMUnlock(mh);

    return (isDupe);

}

/***********************************************************************
 *
 * FUNCTION:	AddCatOK
 *
 * CALLED BY:	MSG_NEW_CATEGORY,  MSG_IMPORT_QIF
 *
 * STRATEGY:    
 *		
 *
 ***********************************************************************/
void AddCatOK(void)
{
MemHandle		mh;
VMBlockHandle	vmbh;
VMMapStruct	*VMmapPtr;

    /* it's OK so finish up */
    catNumItems++;

    /* put the new number of cats into the map */
    vmbh = VMGetMapBlock(GPCBnkrFile);
    VMmapPtr = VMLock(GPCBnkrFile, vmbh, &mh);
    VMmapPtr->MS_catNumber = catNumItems;
    VMDirty(mh);
    VMUnlock(mh);

    /* Let the lists know about the new category */
  /*  newCatSel = GIGS_NONE;
  /*  currentCat = GIGS_NONE;*/
    newCatSel = currentCat;
    @send CatNewSub::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    @send CatModify::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    @send CatDelete::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    if (formUp) @send CatUse::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
  /*  @send CatDList::MSG_GEN_ITEM_GROUP_SET_NONE_SELECTED(FALSE); */
    @call CatDList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(catNumItems);
    @call CatDList::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(currentCat, FALSE);
    @call process::MSG_CAT_DLIST_MONIKER_QUERY(
						    @CatDList,
						    currentCat);
    @call AddMCatDList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(catNumItems);
    @call CSDList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(catNumItems);

}

/***********************************************************************
 *
 * FUNCTION:	ChangeCharAttr
 *
 * CALLED BY:	MSG_CREATE_REPORT
 *
 * STRATEGY:    
 *		
 *
 ***********************************************************************/
void ChangeCharAttr(optr whichAttrs)
{
    dword		rangeStart;
    VisTextCharAttr     *attr;


    rangeStart = @call TextWindow::MSG_VIS_TEXT_GET_TEXT_SIZE();
    MemLock(OptrToHandle(whichAttrs));
    attr = LMemDeref(whichAttrs);
    @call TextWindow::MSG_VIS_TEXT_SET_CHAR_ATTR(
		      attr,
			 TEXT_ADDRESS_PAST_END,
			 rangeStart);
    MemUnlock(OptrToHandle(whichAttrs));

    if (whichAttrs == @GPCBnkrTotalsCharAttrs) {
	  if (!onTV)
		@call TextWindow::MSG_VIS_TEXT_MOVE_TAB(
			    5.5 * 8 * PIXELS_PER_INCH,   /* to */
			    5 * 8 * PIXELS_PER_INCH,   /* from */
			    TEXT_ADDRESS_PAST_END,
			    rangeStart);
	  else
		@call TextWindow::MSG_VIS_TEXT_MOVE_TAB(
			    4.5 * 8 * PIXELS_PER_INCH,   /* to */
			    4 * 8 * PIXELS_PER_INCH,   /* from */
			    TEXT_ADDRESS_PAST_END,
			    rangeStart);
	  }

    if (whichAttrs == @GPCBnkrTextCharAttrs) {
	  if (!onTV)
		@call TextWindow::MSG_VIS_TEXT_MOVE_TAB(
			    5 * 8 * PIXELS_PER_INCH,   /* to */
			    5.5 * 8 * PIXELS_PER_INCH,   /* from */
			    TEXT_ADDRESS_PAST_END,
			    rangeStart);
	  else
		@call TextWindow::MSG_VIS_TEXT_MOVE_TAB(
			    4 * 8 * PIXELS_PER_INCH,   /* to */
			    4.5 * 8 * PIXELS_PER_INCH,   /* from */
			    TEXT_ADDRESS_PAST_END,
			    rangeStart);
	  }

}

/***********************************************************************
 *
 * FUNCTION:	ChangeParaAttr
 *
 * CALLED BY:	MSG_CREATE_REPORT
 *
 * STRATEGY:    
 *		
 *
 ***********************************************************************/
void ChangeParaAttr(optr whichAttrs)
{
dword		rangeStart;
VisTextParaAttr     *attr;


    rangeStart = @call TextWindow::MSG_VIS_TEXT_GET_TEXT_SIZE();
    MemLock(OptrToHandle(whichAttrs));
    attr = LMemDeref(whichAttrs);
    @call TextWindow::MSG_VIS_TEXT_SET_PARA_ATTR(
		      attr,
		      TEXT_ADDRESS_PAST_END,
		      rangeStart);
    MemUnlock(OptrToHandle(whichAttrs));

}

/***********************************************************************
 *
 * FUNCTION:	ClearDisplay
 *
 * CALLED BY:	MSG_DELETE_ACCOUNT, MSG_DETATCH_DOC_FROM_UI
 *
 * STRATEGY:
 *
 *
 ***********************************************************************/
void ClearDisplay()
{

    /* set the various UI elements not enabled */
    @send ImpEx::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    @send CkPrint::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    @send AcctViewMenuItem::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
    @send AcctManageMenuItem::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    @send AcctReconcileMenuItem::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    @send AcctCreateRptMenuItem::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    @send EntriesMenu::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    @send ListsMenu::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    @send FindMenuItem::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    @send FindButton::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    @send SelectAcctTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    @send ButtonGroup::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    
    /* clear the view menu */
    @call process::MSG_UPDATE_VIEW_MENU(UV_CLEAR);
    @call AcctNameGlyph::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
					" ",
					VUM_DELAYED_VIA_APP_QUEUE);

    /* and the register list */
    @call RegisterDList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(6);

    numTrans = 0;

 }

/***********************************************************************
 *
 * FUNCTION:	EnableUI
 *
 * CALLED BY:	MSG_ATTACH_UI,  MSG_NEW_ACCOUNT
 *
 * STRATEGY:
 *
 *
 ***********************************************************************/
void EnableUI(void)
{


    /* set the various UI elements enabled */
    @send ImpEx::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    @send CkPrint::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    @send AcctViewMenuItem::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
    @send AcctManageMenuItem::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    @send AcctReconcileMenuItem::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    @send AcctCreateRptMenuItem::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    @send EntriesMenu::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    @send ListsMenu::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    @send FindMenuItem::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    @send FindButton::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    @send ButtonGroup::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    if (numAccounts > 1)
	  @send SelectAcctTrigger::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);

}
    
 /***********************************************************************
 *
 * FUNCTION:	MakeDateNum
 *
 * CALLED BY:	lots of places
 *
 * STRATEGY:    converts a date to a single dword number for ease
 *		of sort comparisons
 *
 ***********************************************************************/
dword MakeDateNum(TimerDateAndTime date)
{
dword		dateNum;


    dateNum = ((dword)(date.TDAT_year) * (dword)10000) +
	      ((dword)(date.TDAT_month) * (dword)100) +
	      (dword)(date.TDAT_day);

    return(dateNum);

}

/***********************************************************************
 *
 * FUNCTION:	AckDBox (char* string1, char* string2, optr ackMsg)
 *
 * CALLED BY:
 *
 *
 * STRATEGY:    returns user's Yes or No response
 *
 *
 ***********************************************************************/
word AckDBox (char* string1, char* string2, optr ackMsg)
{

    /* put up an Are you sure box */
    MemLock (OptrToHandle(@AcctSP));
    if ((UserStandardDialog((char*)0,
			    (char*)0,
			    string2,
			    string1,
			    LMemDeref(ackMsg),
			    ((CDT_WARNING << CDBF_DIALOG_TYPE_OFFSET) |
			    (GIT_AFFIRMATION << CDBF_INTERACTION_TYPE_OFFSET))
			    ) != IC_YES))  {
	  MemUnlock (OptrToHandle(@AcctSP));
	  return(ACK_NO);
	  }
	 else  {
	  MemUnlock (OptrToHandle(@AcctSP));
	  return(ACK_YES);
	  }

}


/***********************************************************************
 *
 * FUNCTION:	NotifyDBox  (char* string1, optr notifyMsg)
 *
 * CALLED BY:
 *
 *
 * STRATEGY:    Puts up selected notification box
 *
 *
 ***********************************************************************/
void NotifyDBox (char* string1, optr notifyMsg)
{

    /* put up a notification box */
    MemLock (OptrToHandle(@AcctSP));
    UserStandardDialog((char*)0,
			  (char*)0,
			  (char*)0,
			  string1,
			  LMemDeref(notifyMsg),
			  ((CDT_NOTIFICATION << CDBF_DIALOG_TYPE_OFFSET) |
			  (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET)));
    MemUnlock (OptrToHandle(@AcctSP));

}

/***********************************************************************
 *
 * FUNCTION:	TotalAllAccounts  (void)
 *
 * CALLED BY:  OPEN_MANAGE_ACCOUNTS, DELETE_ACCOUNT
 *
 *
 * STRATEGY:
 *
 *
 ***********************************************************************/
void TotalAllAccounts (void)
{
 ChunkHandle		chunk;
 MemHandle		mem;
 GStateHandle		gstate;
 word			width, i;
 char			amtString[MAX_TEXT_LEN], totalString[MAX_TEXT_LEN + 10];
 AcctStruct		*acct;
 DBMapStruct*		mapPtr;
 FloatNum			totalAccounts;


    /* grab the account balances */
	FLOAT_SET_FLOATNUM_TO_0(totalAccounts);
    mapPtr = DBLockMap(GPCBnkrFile);
    acct = (AcctStruct *) (mapPtr + sizeof(DBMapStruct));
    for (i = 0; i < numAccounts; i++)  {
	  FloatPushNumber(&totalAccounts);
	  FloatPushNumber(&acct[i].AS_balance);
	  FloatAdd();
	  FloatPopNumber(&totalAccounts);
	  }
    DBUnlock(mapPtr);
    FloatFloatToAscii_StdFormat(amtString,
							&totalAccounts,
							FFAF_FROM_ADDR,
							14,
							2);

    strcpy(totalString, "Total:  ");
    strcat(totalString, amtString);
    mem = MemAllocLMem(LMEM_TYPE_GSTRING, 0);
    gstate = GrCreateGString(mem, GST_CHUNK, (word*)&chunk);
    GrSetTextColor(gstate, CF_INDEX, C_BLACK, 0, 0);
    GrSetLineWidth(gstate, MakeWWFixed(2));
    GrSetLineColor(gstate, CF_INDEX, C_BLACK, 0, 0);
    /* get length to size line */
    width = GrTextWidth(gstate, amtString, strlen(amtString));
    GrDrawHLine(gstate, 135 - width - 10, 0, 135);  /* L, B, R */
    /* get length to right justify */
    width = GrTextWidth(gstate, totalString, strlen(totalString));
    GrDrawText(gstate, 135 - width, 0, totalString, 0);
    GrEndGString(gstate) ;

    @call MNATotal::MSG_GEN_REPLACE_VIS_MONIKER(
				  VUM_NOW,
				  16,				/* height */
				  150,				/* width */
				  0,
				  VMDT_GSTRING,
				  VMST_OPTR,
				  ConstructOptr(mem, chunk));

    /* and 86 the gstate and mem */
    GrDestroyGString(gstate, gstate, GSKT_KILL_DATA) ;
    MemFree(mem) ;

}

/***********************************************************************
 *
 * FUNCTION:	AmountChecksOK
 *                   (char balString[DOLLAR_IN_SIZE], Boolean NegOK)
 * CALLED BY:  all amount input routines
 *
 *
 * STRATEGY:   makes sure the string will parse out as a valid amount
 *             returns TRUE if amount will work
 *
 ***********************************************************************/
Boolean AmountChecksOK(char amountStr[DOLLAR_IN_SIZE],
				   Boolean NegOK,
				   Boolean zeroOK)
{
word		i, decPos, numDigits = 0;
Boolean	checksOK = TRUE, foundDec = FALSE;
FloatNum		amount;


    for (i = 0; i < strlen(amountStr); i++)  {
	  if (!LocalIsDigit((word) amountStr[i])) {
		/* is it a - in position 0? */
		if ((amountStr[i] == '-') && i && NegOK) {
		   checksOK = FALSE;
		   i = DOLLAR_IN_SIZE;
		   }
		/* is it a multiple decimal separator? */
		if (amountStr[i] == '.')  {
		   if (foundDec)  {
			 checksOK = FALSE;
			 i = DOLLAR_IN_SIZE;
			 }
		   else {
			 foundDec = TRUE;
			 decPos = i;
			 }
		   }
		}  /* end of not a digit */
	  else numDigits++;
	  } /* end of for loop */

    /* test for too many digits after decimal */
    if (foundDec && ((i - decPos) > 3))  checksOK = FALSE;

    /* test for no digits  */
    if (!numDigits)  checksOK = FALSE;

    /* check for zero if zero !ok */
    if (checksOK && !zeroOK) {
	 /* convert the string to a value */
	 FloatAsciiToFloat(FAF_STORE_NUMBER,
			strlen(amountStr),
			amountStr,
			&amount);
	 FloatPushNumber(&amount);
	 Float0();
	 if (!FloatCompAndDrop()) checksOK = FALSE;
	 }

    if (!checksOK) NotifyDBox(amountStr, @InvalidAmountMsg);

    return(checksOK);

}



