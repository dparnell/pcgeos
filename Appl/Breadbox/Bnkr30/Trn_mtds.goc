
/**************************************************************
 *  ==CONFIDENTIAL INFORMATION==
 *  COPYRIGHT 1994-2000 BREADBOX COMPUTER COMPANY --
 *  ALL RIGHTS RESERVED  --
 *  THE FOLLOWING CONFIDENTIAL INFORMATION IS BEING DISCLOSED TO YOU UNDER A
 *  NON-DISCLOSURE AGREEMENT AND MAY NOT BE DISCLOSED OR FORWARDED BY THE
 *  RECIPIENT TO ANY OTHER PERSON OR ENTITY NOT COVERED BY THE SAME
 *  NON-DISCLOSURE AGREEMENT COVERING THE RECIPIENT. USE OF THE FOLLOWING
 *  CONFIDENTIAL INFORMATION IS RESTRICTED TO THE TERMS OF THE NON-DISCLOSURE
 *  AGREEMENT.
 **************************************************************/

/*
 **************************************************************************
 *  FILE:			trn_mtds.goc
 *  PROJECT:		GPC Banker
 *  DESCRIPTION:	This file has methods for the transaction
 *			functions
 **************************************************************************
 */
/*
 ***************************************************************************
 *		Include files
 ***************************************************************************
 */

@include "bnkr30.goh"
@include "externs.goh"

Boolean CanModify = TRUE;

/*
 ***************************************************************************
 *		Class & Message Definitions
 ***************************************************************************
 */

/* entry win class defined in bnkr.goh */
@classdecl	GPCBnkrEntryInteractionClass;

/* form drawing class defined in bnkr.goh */
//@classdecl	GPCBnkrFormInteractionClass;


/****************************************************************************
 *		Code for GPCBnkrProcessClass Transactions stuff
 ***************************************************************************
 */

/***********************************************************************
 *
 * FUNCTION:	DeleteTransaction(word whichDelete)
 *
 * CALLED BY:	MSG_DELETE_TRANS, MSG_MODIFY_TRANS
 *
 * STRATEGY:    
 *		
 *
 ***********************************************************************/
 void DeleteTransaction(word whichDelete)
{
AcctStruct	*account;
TransStruct	*trans;
DBItem		transItem;
DBGroup		acctGroup, multiGroup;
DBMapStruct*	mapPtr;
word			i, transType;
FloatNum		balance, amount;
Boolean		isMulti = FALSE;
TransSortStruct	*trArrayElement;
MemHandle		mh;
MemHandle			indexMH;


    /* Standard setup */
    mapPtr = DBLockMap(GPCBnkrFile);
    account = (AcctStruct *) (mapPtr + sizeof(DBMapStruct));
    acctGroup = account[currentAcct].AS_group;

    /* get the index array VMBlock */
    transListVMBHandle = VMFind(GPCBnkrFile, NullHandle, (currentAcct*10)+ALLSORT);
    VMLock(GPCBnkrFile, transListVMBHandle ,&indexMH);
    /* get the selected element info */
    trArrayElement = ChunkArrayElementToPtrHandles(
		   indexMH,
		   transListChunkArray,
		   whichDelete,
		   0);
    transItem = trArrayElement->TSS_item;
    transType = trArrayElement->TSS_type;
  /*  VMDirty(indexMH); */
    VMUnlock(indexMH);

    trans = DBLock(GPCBnkrFile, acctGroup, transItem);

    /* get the amount*/
    amount = trans->TS_amount;

    /* adjust the balance */
    if ((transType == TRANS_CK)
			   || (transType == TRANS_DB)
			   || (transType == TRANS_XFM)) {
       /* add back in old amount */
	   FloatPushNumber(&amount);
	   FloatPushNumber(&account[currentAcct].AS_balance);
	   FloatAdd();
	   FloatPopNumber(&balance);
       }
      else  {  /* a deposit/credit */
       /* subtract out old amount */
       FloatPushNumber(&account[currentAcct].AS_balance);
	   FloatPushNumber(&amount);
       FloatSub();
       FloatPopNumber(&balance);
	  }
    account[currentAcct].AS_balance = balance;
    account[currentAcct].AS_numTrans--;
    numTrans--;
    DBDirty(mapPtr);
    DBUnlock(mapPtr);

    /* see if it is a multi */
    if (trans->TS_numMultis) {
	  isMulti = TRUE;
	  multiGroup = trans->TS_multiGroup;
	  }

    /* delete the item */
    DBUnlock(trans);
    DBFree(GPCBnkrFile, acctGroup, transItem);

    /* If this was a multi parent delete it's kids - just axe the DBGroup*/
    if (isMulti)  {
	  DBGroupFree(GPCBnkrFile, multiGroup);
	  }

    /* now we have to adjust the running balance(s) */
    /* get the sort list */
    transListVMBHandle = VMFind(GPCBnkrFile, NullHandle, (currentAcct*10)+ALLSORT);
    VMLock(GPCBnkrFile, transListVMBHandle, &mh);

    /* first see if there is only 1 transaction */
    if (numTrans == 1)  {
	  if (whichDelete == 1) {
		trArrayElement = ChunkArrayElementToPtrHandles(
				    mh,
				    transListChunkArray,
				    0,
				    0);
		trArrayElement->TSS_runBal = balance;
		}
	  else  {
		trArrayElement = ChunkArrayElementToPtrHandles(
				    mh,
				    transListChunkArray,
				    1,
				    0);
		trArrayElement->TSS_runBal = balance;
		}
	  }
    else  { /* more than one */
	  /* did we delete the 1st transaction? */
	  if (whichDelete == 0)  {
		/* take care of this tranaction */
		trArrayElement = ChunkArrayElementToPtrHandles(
				    mh,
				    transListChunkArray,
				    whichDelete,
				    0);
		trArrayElement->TSS_runBal = balance;
		}
	  else {
		/* first get the previous balance */
		trArrayElement = ChunkArrayElementToPtrHandles(
				    mh,
				    transListChunkArray,
				    whichDelete - 1,
				    0);
		balance = trArrayElement->TSS_runBal;

		/* now take care of this tranaction */
		trArrayElement = ChunkArrayElementToPtrHandles(
				    mh,
				    transListChunkArray,
				    whichDelete,
				    0);
		trArrayElement->TSS_runBal = balance;
		}

	  /* and now all the later transactions */
	  for (i = (whichDelete + 1); i < (numTrans + 1); i++)  {
		trArrayElement = ChunkArrayElementToPtrHandles(
				    mh,
				    transListChunkArray,
				    i,
				    0);
		/* and update the balance */
		if ((transType == TRANS_CR) || (transType == TRANS_DP)
			|| (transType == TRANS_XFP))  {
		   /* sub check/debit amount */
		   FloatPushNumber(&trArrayElement->TSS_runBal);
		   FloatPushNumber(&amount);
		   FloatSub();
		   FloatPopNumber(&trArrayElement->TSS_runBal);
		   }
		else  {  /* add deposit/credit amount */
		   FloatPushNumber(&amount);
		   FloatPushNumber(&trArrayElement->TSS_runBal);
		   FloatPopNumber(&trArrayElement->TSS_runBal);
		   }
		} /* end of later transactions for loop */
	  }  /* end of more than one trans else */
    VMDirty(mh);
    VMUnlock(mh);

    /* now delete the index array item */
    TransIndexDelete(whichDelete);

    return;
}

/***********************************************************************
 *
 * FUNCTION:	VoidTransaction(word whichVoid)
 *
 * CALLED BY:	MSG_VOID_TRANS
 *
 * STRATEGY:    
 *		
 *
 ***********************************************************************/
 void VoidTransaction(word whichVoid)
{
AcctStruct	*account;
TransStruct	*trans;
DBItem		transItem, multiItem;
DBGroup		acctGroup, multiGroup;
DBMapStruct*	mapPtr;
word			i/*, transaction*/;
FloatNum		balance, amount;
Boolean		isMulti = FALSE;
TransSortStruct	*trArrayElement;
MemHandle		mh;
MemHandle			indexMH;


    /* Standard setup */
    mapPtr = DBLockMap(GPCBnkrFile);
    account = (AcctStruct *) (mapPtr + sizeof(DBMapStruct));
    acctGroup = account[currentAcct].AS_group;
    /* get the index array VMBlock */
    transListVMBHandle = VMFind(GPCBnkrFile, NullHandle, (currentAcct*10)+ALLSORT);
    VMLock(GPCBnkrFile, transListVMBHandle ,&indexMH);
    /* get the selected element info */
    trArrayElement = ChunkArrayElementToPtrHandles(
		   indexMH,
		   transListChunkArray,
		   whichVoid,
		   0);
    transItem = trArrayElement->TSS_item;
    currentType = trArrayElement->TSS_type;
    trArrayElement->TSS_cleared = TRUE;
    VMDirty(indexMH);
    VMUnlock(indexMH);

    trans = DBLock(GPCBnkrFile, acctGroup, transItem);

    /* adjust the balance */
    if ((currentType == TRANS_CK)
				   || (currentType == TRANS_DB)
				   || (currentType == TRANS_XFM)) {
	  /* add back in old amount */
	  FloatPushNumber(&account[currentAcct].AS_balance);
	  FloatPushNumber(&trans->TS_amount);
	  FloatAdd();
	  FloatPopNumber(&balance);
	  }
	 else  {  /* a deposit/credit */
	  /* subtract out old amount */
	  FloatPushNumber(&account[currentAcct].AS_balance);
	  FloatPushNumber(&trans->TS_amount);
	  FloatSub();
	  FloatPopNumber(&balance);
	  }
    amount = trans->TS_amount;

    /* and store modified balance */
    account[currentAcct].AS_balance = balance;
    DBDirty(mapPtr);
    DBUnlock(mapPtr);

    /* see if it is a multi */
    if (trans->TS_numMultis) {
	  isMulti = TRUE;
	  numMultis = trans->TS_numMultis;
	  multiGroup = trans->TS_multiGroup;
	  multiItem = trans->TS_multiItem;
	  }

    /* update the database... */
    MemLock (OptrToHandle(@ModTransMsg));
    strcpy(trans->TS_payee, LMemDeref(@VoidLongText));
    MemUnlock (OptrToHandle(@ModTransMsg));
    strcpy(trans->TS_memo, "");
    if (!isMulti)  {   /* if it is a multiParent leave cat alone */
	  strcpy(trans->TS_category, "");
	  }
    FLOAT_SET_FLOATNUM_TO_0(trans->TS_amount);
    trans->TS_taxItem = FALSE;
    /* Mark the trans item as dirty and unlock it. */
    DBDirty(trans);
    DBUnlock(trans);

    /* If this was a multi parent change it's kids' info
	* in the database */
    if (isMulti)  {
	  for (i = 0; i < numMultis; i++)  {
		trans = DBLock(GPCBnkrFile, multiGroup, multiItem);
		multiItem = trans->TS_multiItem;
		/* make the changes... */
		MemLock (OptrToHandle(@ModTransMsg));
		strcpy(trans->TS_memo, LMemDeref(@VoidText));
		MemUnlock (OptrToHandle(@ModTransMsg));
		strcpy(trans->TS_category, "");
		FLOAT_SET_FLOATNUM_TO_0(trans->TS_amount);
		DBDirty(trans);
		DBUnlock(trans);
		}
	  }


    /* now we have to adjust the running balance(s) */
    /* get the sort list */
    transListVMBHandle = VMFind(GPCBnkrFile, NullHandle, (currentAcct*10)+ALLSORT);
    VMLock(GPCBnkrFile, transListVMBHandle, &mh);

    /* first see if there is only 1 transaction */
    if (numTrans == 1)  {
	  trArrayElement = ChunkArrayElementToPtrHandles(
				    mh,
				    transListChunkArray,
				    0,
				    0);
	/*  trArrayElement->TSS_runBal = balance; */
      FLOAT_SET_FLOATNUM_TO_0(balance);
	  if ((currentType == TRANS_CK) || (currentType == TRANS_DB)
			|| (currentType == TRANS_XFM))  {
		/* sub check/debit amount */
		FloatPushNumber(&balance);
		FloatPushNumber(&amount);
		FloatSub();
		FloatPopNumber(&trArrayElement->TSS_runBal);
		}
	  else  {  /* add deposit/credit amount */
	    FloatPushNumber(&balance);
		FloatPushNumber(&amount);
		FloatAdd();
		FloatPopNumber(&trArrayElement->TSS_runBal);
		}
	  }
    else  { /* more than one */
	  /* did we void the 1st transaction? */
	  if (whichVoid == 0)  {
		/* take care of this tranaction */
		trArrayElement = ChunkArrayElementToPtrHandles(
				    mh,
				    transListChunkArray,
				    whichVoid,
				    0);
		FLOAT_SET_FLOATNUM_TO_0(trArrayElement->TSS_runBal);
		}
	  else {
		/* first get the previous balance */
		trArrayElement = ChunkArrayElementToPtrHandles(
				    mh,
				    transListChunkArray,
				    whichVoid - 1,
				    0);
		balance = trArrayElement->TSS_runBal;

		/* now take care of this tranaction */
		trArrayElement = ChunkArrayElementToPtrHandles(
				    mh,
				    transListChunkArray,
				    whichVoid,
				    0);
		trArrayElement->TSS_runBal = balance;
		}

	  /* and now all the later transactions */
	  for (i = (whichVoid + 1); i < numTrans; i++)  {
		trArrayElement = ChunkArrayElementToPtrHandles(
				    mh,
				    transListChunkArray,
				    i,
				    0);
		/* and update the balance */
		if ((currentType == TRANS_CR) || (currentType == TRANS_DP)
			|| (currentType == TRANS_XFP))  {
		   /* sub check/debit amount */
		   FloatPushNumber(&trArrayElement->TSS_runBal);
		   FloatPushNumber(&amount);
		   FloatSub();
		   FloatPopNumber(&trArrayElement->TSS_runBal);
		   }
		else  {  /* add deposit/credit amount */
		   FloatPushNumber(&amount);
		   FloatPushNumber(&trArrayElement->TSS_runBal);
		   FloatAdd();
		   FloatPopNumber(&trArrayElement->TSS_runBal);
		   }
		} /* end of later transactions for loop */
	  }  /* end of more than one trans else */
    VMDirty(mh);
    VMUnlock(mh);

}

/***********************************************************************
 *
 * MESSAGE:	MSG_OPEN_ENTRY() for GPCBnkrProcessClass
 *
 * DESCRIPTION:	sets up and opens the new Entry dbox.
 *
 * PARAMETERS:      word whichEntry (new, mod)
 *
 *
 ***********************************************************************/
@extern method GPCBnkrProcessClass, MSG_OPEN_ENTRY
{
AcctStruct	*acct;
DBGroupAndItem	mapitem;
DBMapStruct*	mapPtr;
char			numString[CKNUM_SIZE];
word			transaction;
TransStruct	*trans;
DBItem		transItem;
char			amtString[MAX_TEXT_LEN];
char			dateString[DATE_SIZE];
TimerDateAndTime	date;
MemHandle			indexMH;
TransSortStruct	*trArrayElement;
Boolean		isCleared;


	 /* some initialization */
	 numMultis = 0;
	 @send NEFCatText::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
	 @call NEFCatText::MSG_GEN_SET_ATTRS(0, GA_READ_ONLY);
	 @send NEFCatText::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
	 CanModify = TRUE;

	 /* which form - new or mod */
	 if (whichEntry == E_NEW) {
	  /* clear the fields */
	  @send NEFDAmount::MSG_VIS_TEXT_DELETE_ALL();
	  @send NEFPayText::MSG_VIS_TEXT_DELETE_ALL();
	  @send NEFMemoText::MSG_VIS_TEXT_DELETE_ALL();
	  @send NEFCatText::MSG_VIS_TEXT_DELETE_ALL();
	  @send NEFTax::MSG_GEN_BOOLEAN_GROUP_SET_GROUP_STATE(0, 0);

	  /* set the form to check */
	  @call process::MSG_SET_ENTRY_FORM(TRANS_CK);
	//  @send NEType::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	  @call NEType::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(TRANS_CK, FALSE);
	  if (numAccounts > 1)
		@send NETXfer::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	  else
		@send NETXfer::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	  /* see if we need to auto number the check */
	  if (autoNum)  {
		  mapitem = DBGetMap(GPCBnkrFile);
		  mapPtr = DBLockUngrouped(GPCBnkrFile, mapitem);
		  acct = (AcctStruct *) (mapPtr + sizeof(DBMapStruct));
		  if (acct[currentAcct].AS_nextNum)  {
			  UtilHex32ToAscii(numString,
				    (sdword) acct[currentAcct].AS_nextNum,
				    UHTAF_NULL_TERMINATE);
			  @call NEFDCheckNum::MSG_VIS_TEXT_REPLACE_ALL_PTR(numString, 0);
			  }
		  DBUnlock(mapPtr);
		  }
	  else @send NEFDCheckNum::MSG_VIS_TEXT_DELETE_ALL();
	  /* put in the right title and button */
	  MemLock (OptrToHandle(@NewEntryMoniker));
	  @call NewEntryDBox::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
			   LMemDeref(@NewEntryMoniker),
			   VUM_DELAYED_VIA_APP_QUEUE);
	  @call NECancel::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
			   LMemDeref(@CancelMoniker),
			   VUM_DELAYED_VIA_APP_QUEUE);
	  MemUnlock (OptrToHandle(@NewEntryMoniker));
	  @send NERecord::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
	  @send NEModify::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
	  } /* end of its a new entry */

    if (whichEntry == E_MOD) {
	  /* get the selected trans */
	  transaction = @call RegisterDList::MSG_GEN_ITEM_GROUP_GET_SELECTION();
	  /* get the index array VMBlock */
	  transListVMBHandle = VMFind(GPCBnkrFile, NullHandle, (currentAcct*10)+ALLSORT);
	  VMLock(GPCBnkrFile, transListVMBHandle ,&indexMH);
	  /* get the selected element info */
	  trArrayElement = ChunkArrayElementToPtrHandles(
		   indexMH,
		   transListChunkArray,
		   transaction,
		   0);
	  transItem = trArrayElement->TSS_item;
	  currentType = trArrayElement->TSS_type;
	  isCleared = trArrayElement->TSS_cleared;
	  VMUnlock(indexMH);
	  /* if a xfer tell the user no */
	  if ((currentType == TRANS_XFP) || (currentType == TRANS_XFM)) {
		NotifyDBox(0, @CantModXferMsg);
		return;
		}
// XXX
	  /* if cleared warn that can only view */
	  if (isCleared) {
		NotifyDBox(0, @CantModClearedWarnMsg);
		CanModify = FALSE;
  //		return;
		}
	  @call process::MSG_SET_ENTRY_FORM(currentType);
	  @call NEType::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(currentType, FALSE);
    //	  @send NEType::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
    //	  @send NEType::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
       @send NETXfer::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	  /* collect the transaction data  */
	  trans = DBLock(GPCBnkrFile, currentAcctGroup, transItem);
	  if (currentType == TRANS_CK) {
		UtilHex32ToAscii(numString,
					  (sdword) trans->TS_number,
					  UHTAF_NULL_TERMINATE);
		@call NEFDCheckNum::MSG_VIS_TEXT_REPLACE_ALL_PTR(numString, 0);
		}
	  /* get the date values  */
	  date.TDAT_year = trans->TS_year;
	  date.TDAT_month = trans->TS_month;
	  date.TDAT_day = trans->TS_day;
	  /* format it */
	  LocalFormatDateTime(dateString, DTF_SHORT, &date);
	  @call NEFDDate::MSG_VIS_TEXT_REPLACE_ALL_PTR(dateString, 0);
	  /* convert the amount */
	  FloatFloatToAscii_StdFormat(amtString,
						 &trans->TS_amount,
						 FFAF_FROM_ADDR,
						 14,
						 2);
	  @call NEFDAmount::MSG_VIS_TEXT_REPLACE_ALL_PTR(amtString, 0);
	  @call NEFPayText::MSG_VIS_TEXT_REPLACE_ALL_PTR(trans->TS_payee, 0);
	  @call NEFMemoText::MSG_VIS_TEXT_REPLACE_ALL_PTR(trans->TS_memo, 0);
	  @call NEFCatText::MSG_VIS_TEXT_REPLACE_ALL_PTR(trans->TS_category, 0);
	  if (trans->TS_taxItem)
		@call NEFTax::MSG_GEN_BOOLEAN_GROUP_SET_GROUP_STATE(TI_TAX, 0);
	  else
		@call NEFTax::MSG_GEN_BOOLEAN_GROUP_SET_GROUP_STATE(0, 0);
	  if (trans->TS_numMultis) {
		  /* make cat field read only */
		  @send NEFCatText::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		  @call NEFCatText::MSG_GEN_SET_ATTRS(GA_READ_ONLY, 0);
		  @send NEFCatText::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		  }
	  DBUnlock(trans);
	  /* put in the right title and button*/
	  MemLock (OptrToHandle(@ModEntryMoniker));
	  @call NewEntryDBox::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
			   LMemDeref(@ModEntryMoniker),
			   VUM_DELAYED_VIA_APP_QUEUE);
	  @call NECancel::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
			   LMemDeref(@DontChangeMoniker),
			   VUM_DELAYED_VIA_APP_QUEUE);
	  MemUnlock (OptrToHandle(@ModEntryMoniker));
	  @send NEModify::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
	  @send NERecord::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
	  } /* end of its a modify entry */

    /* Open the dialog box */
    @call NewEntryDBox::MSG_GEN_INTERACTION_INITIATE();
    formUp++;

}

/***********************************************************************
 *
 * MESSAGE:	MSG_SET_ENTRY_FORM() for GPCBnkrProcessClass
 *
 * DESCRIPTION:
 *
 * PARAMETERS:     void (word whichType)
 *
 *
 ***********************************************************************/
@extern method GPCBnkrProcessClass, MSG_SET_ENTRY_FORM
{


    MemLock (OptrToHandle(@AcctSP));
    switch (whichType) {
	  case TRANS_CK:
		currentType = TRANS_CK;
		@call NEFTypeText::MSG_VIS_TEXT_REPLACE_ALL_PTR(LMemDeref(@TypeTextCheck), 0);
//          formBitmap = BANKER_BITMAP_CHECK;
		@call NEFPayButton::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
				LMemDeref(@PayTo),
			   VUM_DELAYED_VIA_APP_QUEUE);
		/* turn off */
		@send NEFDCheckFill::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFMultiFiller::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFTaxFiller::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFXFerFmLine::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFXFerToLine::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		/* turn on */
		@send NEFDCheckNum::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFPayLine::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFCatLine::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFMultiLine::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFTaxLine::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		break;
	  case TRANS_DP:
		currentType = TRANS_DP;
		@call NEFTypeText::MSG_VIS_TEXT_REPLACE_ALL_PTR(LMemDeref(@TypeTextDeposit), 0);
//		formBitmap = BANKER_BITMAP_DEPOSIT;
		@call NEFPayButton::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
			   LMemDeref(@From),
			   VUM_DELAYED_VIA_APP_QUEUE);
		/* turn off */
		@send NEFDCheckNum::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFMultiFiller::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFTaxLine::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFXFerFmLine::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFXFerToLine::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		/* turn on */
		@send NEFDCheckFill::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFPayLine::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFCatLine::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFMultiLine::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFTaxFiller::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		break;
	  case TRANS_DB:
		currentType = TRANS_DB;
		@call NEFTypeText::MSG_VIS_TEXT_REPLACE_ALL_PTR(LMemDeref(@TypeTextDebit), 0);
 //		formBitmap = BANKER_BITMAP_DEBIT;
		@call NEFPayButton::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
			   LMemDeref(@To),
			   VUM_DELAYED_VIA_APP_QUEUE);
		/* turn off */
		@send NEFDCheckNum::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFMultiFiller::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFTaxLine::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFXFerFmLine::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFXFerToLine::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		/* turn on */
		@send NEFDCheckFill::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFPayLine::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFCatLine::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFMultiLine::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFTaxFiller::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		break;
	  case TRANS_CR:
		currentType = TRANS_CR;
		@call NEFTypeText::MSG_VIS_TEXT_REPLACE_ALL_PTR(LMemDeref(@TypeTextCredit), 0);
//		formBitmap = BANKER_BITMAP_CREDIT;
		@call NEFPayButton::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(
			   LMemDeref(@From),
			   VUM_DELAYED_VIA_APP_QUEUE);
		/* turn off */
		@send NEFDCheckNum::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFMultiFiller::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFTaxLine::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFXFerFmLine::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFXFerToLine::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		/* turn on */
		@send NEFDCheckFill::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFPayLine::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFCatLine::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFMultiLine::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFTaxFiller::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		break;
	  case TRANS_XFP:
		currentType = TRANS_XFP;
		@call NEFTypeText::MSG_VIS_TEXT_REPLACE_ALL_PTR(LMemDeref(@TypeTextXfer), 0);
//          formBitmap = BANKER_BITMAP_XFER;
		/* turn off */
		@send NEFDCheckNum::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFPayLine::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFCatLine::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFMultiLine::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFTaxLine::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		/* turn on */
		@send NEFDCheckFill::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFXFerFmLine::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFXFerToLine::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFMultiFiller::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		@send NEFTaxFiller::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
		/* set the first two accounts */
		@send NEFXFerFmList::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(0, FALSE);
		@send NEFXFerToList::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(1, FALSE);
		fromAcct = 0;
		toAcct = 1;
		break;
	  } /* end of switch */
    MemUnlock (OptrToHandle(@AcctSP));
    /* force the form bitmap to redraw */
    @send NEFormGroup::MSG_GEN_SET_NOT_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
    @send NEFormGroup::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);


}
/***********************************************************************
 *
 * MESSAGE:	MSG_ENTRY_TYPE_LIST_APPLY() for GPCBnkrProcessClass
 *
 * DESCRIPTION:	Handles an apply of user selection in the entries list.
 *
 * PARAMETERS:  void (word selection, numSelections, flags)
 *
 *
 ***********************************************************************/
@extern method GPCBnkrProcessClass, MSG_ENTRY_TYPE_LIST_APPLY
{

    currentType = selection;
    @call process::MSG_SET_ENTRY_FORM(selection);

}

/***********************************************************************
 *
 * MESSAGE:	MSG_ENTER_TRANS for GPCBnkrProcessClass
 *
 * DESCRIPTION:	Creates a new DB item.
 *
 * STRATEGY:    Allocate the new item and fill it in with
 *		      a check/deposit etc...
 *
 ***********************************************************************/
@extern method GPCBnkrProcessClass, MSG_ENTER_TRANS
{
 char		dateString[DATE_SIZE], numString[CKNUM_SIZE];
 char		amtInString[DOLLAR_IN_SIZE], payee[ENTRY_SIZE];
 char		memo[ENTRY_SIZE], cat[ENTRY_SIZE];
 word		length, numRecon, sortPos, i;
 dword		transDateNum, dwnumber, chkNum;
 FloatNum		amount, balance;
 TimerDateAndTime	date;
 Boolean		isTax;
 DBItem		transItem;
 TransSortStruct	*trArrayElement;
 MemHandle		indexMH;


    /* check on limit */
    if (numTrans == 1899) NotifyDBox(0, @TransNumWarnMsg);
    if (numTrans == 2000) {
	  NotifyDBox(0, @TransNumStopMsg);
	  return;
	  }

    if (currentType == TRANS_XFP) {
	  @call process::MSG_ENTER_TRANSFER();
	  return;
	  }

    /* get the new transaction info */
    @call NEFDCheckNum::MSG_VIS_TEXT_GET_ALL_PTR(numString);
    @call NEFDDate::MSG_VIS_TEXT_GET_ALL_PTR(dateString);
    length = @call NEFDAmount::MSG_VIS_TEXT_GET_ALL_PTR(amtInString);
    @call NEFPayText::MSG_VIS_TEXT_GET_ALL_PTR(payee);
    @call NEFMemoText::MSG_VIS_TEXT_GET_ALL_PTR(memo);
    @call NEFCatText::MSG_VIS_TEXT_GET_ALL_PTR(cat);

    /* Exit if no amount */
    if (*amtInString == 0) {
	  NotifyDBox(0, @NoAmountMsg);
	  @send NEFDAmount::MSG_META_GRAB_FOCUS_EXCL();
	  return;
	  }

    /* Exit if amount invalid */
    if (!AmountChecksOK(amtInString, FALSE, FALSE))  {
	  /* send the focus back to the balance field */
	  @send NEFDAmount::MSG_META_GRAB_FOCUS_EXCL();
	  return;
	  }

    /* Exit if date no good */
    if (!DateCheck(dateString))  {
	  /* send the focus back to the date field */
	  @send NEFDDate::MSG_META_GRAB_FOCUS_EXCL();
	  return;
	  }

    /* check the cat */
    if (strlen(cat))  {
	  if (CheckIsNewCat(cat) == FALSE)  {
		/* it was cancel */
		return;
		}
	  /* otherwise the user added the cat or ignored it as new */
	  } /* end of there is a cat if */

    /* get the boolean data */
    isTax = @call NEFTax::MSG_GEN_BOOLEAN_GROUP_IS_BOOLEAN_SELECTED(TI_TAX);

    if (currentType == TRANS_CK)  {
	  /* convert the check num to a value */
	  if (UtilAsciiToHex32(numString, &dwnumber))  chkNum = 0;
	  else  chkNum = dwnumber;
	  /* warn if a duplicate check number */
	  transListVMBHandle = VMFind(GPCBnkrFile, NullHandle, (currentAcct*10)+ALLSORT);
	  VMLock(GPCBnkrFile, transListVMBHandle ,&indexMH);
	  for (i = 0; i < numTrans; i++)  {
		trArrayElement = ChunkArrayElementToPtrHandles(
					 indexMH,
					 transListChunkArray,
					 i,
					 0);
		if (dwnumber == trArrayElement->TSS_ckNumber) {
		   if (AckDBox(numString, 0, @DupeChkNumMsg) == ACK_NO) {
			 VMUnlock(indexMH);
			 @send NEFDCheckNum::MSG_META_GRAB_FOCUS_EXCL();
			 return;
			 }
		   }  /* end of same number if */
		}  /* end of loop thru for */
	  VMUnlock(indexMH);
	  }  /* end of check type if */

    /* convert the amount to a value */
    FloatAsciiToFloat(FAF_STORE_NUMBER,
			length,
			amtInString,
			&amount);

    /* parse the date */
    LocalParseDateTime(dateString, DTF_SHORT, &date);

    /* convert to comparison number */
    transDateNum = MakeDateNum(date);

    /* now call the function that enters this transaction */
    balance =  EnterTransaction(
					FALSE,   /* import */
				   amount,
				date.TDAT_year,
				date.TDAT_month,
				date.TDAT_day,
				chkNum,
					payee,
				   memo,
					cat,
				isTax,
					FALSE,
				&transItem);        /* returned */


    /* add this transaction to the acct sort index array */
    sortPos = TransIndexInsert(transDateNum,
						 date,
						 chkNum,
						 amount,
						 FALSE,
						 transItem);

    /* dismiss the dbox */
    @send NEFCatText::MSG_VIS_TEXT_DELETE_ALL();
    @send NewEntryDBox::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);
 //   formUp--;

    /* init the register dlist */
    if (numTrans > DEFAULT_LIST_LINES-1)
	  @call RegisterDList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(numTrans);
    else
	  @call RegisterDList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(DEFAULT_LIST_LINES);
    @call RegisterDList::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(sortPos, FALSE);
    /* redraw its moniker to show selected */
    @call RegisterDList::MSG_GEN_ITEM_GROUP_SEND_STATUS_MSG(FALSE);
    /* and give the list the focus */
    @send RegisterDList::MSG_META_GRAB_FOCUS_EXCL();



    if (numTrans == 1)  {
	  /* enable buttons since we put in our first trans */
	  @send ModifyButton::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	  @send EntriesModifyMenuItem::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	  @send EntriesDeleteMenuItem::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	  @send EntriesVoidMenuItem::MSG_GEN_SET_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	  }

	 /* update reconcile stuff if necessary */
    if (reconcileFlag)  {
	  numRecon = @call RCLDList::MSG_GEN_DYNAMIC_LIST_GET_NUM_ITEMS();
	  @call RCLDList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(numRecon + 1);
	  }

    if (multiFlag)  {
	  multiFlag = FALSE;
	  FLOAT_SET_FLOATNUM_TO_0(multiAmount);
	  MemFree(multiHeapHandle);
	  multiHeapHandle = NULL;
	  }
}

/***********************************************************************
 *
 * MESSAGE:	MSG_VOID_TRANS for GPCBnkrProcessClass
 *
 * DESCRIPTION:	voids a previously entered transaction
 *
 * STRATEGY:
 *
 *
 ***********************************************************************/
@extern method GPCBnkrProcessClass, MSG_VOID_TRANS
{
TransSortStruct	*trArrayElement;
MemHandle			indexMH;
TransStruct		*trans;
DBGroup			xferGroup;
DBItem			transItem, xferItem;
word			     i, xferAccount, xferSelection, numXferTrans;
word			     saveAccount, saveNumTrans;
AcctStruct		*acct;
DBMapStruct*		mapPtr;
Boolean             foundXferAccount, foundXferSelection;


    /* put up an Are you sure box */
	 if (AckDBox(0, 0, @VoidTransMsg) == ACK_NO) return;


    /* need to see if this is a transfer */
	 transListVMBHandle = VMFind(GPCBnkrFile, NullHandle, (currentAcct*10)+ALLSORT);
	 VMLock(GPCBnkrFile, transListVMBHandle ,&indexMH);
	 trArrayElement = ChunkArrayElementToPtrHandles(
			indexMH,
		   transListChunkArray,
			transSelected,
			0);
	 currentType = trArrayElement->TSS_type;
	 transItem = trArrayElement->TSS_item;
	 VMUnlock(indexMH);
    if ((currentType == TRANS_XFP) || (currentType == TRANS_XFM)) {
	  /* grab the opposite's Group and Item */
	  trans = DBLock(GPCBnkrFile, currentAcctGroup, transItem);
	  xferGroup = trans->TS_multiGroup;
	  xferItem = trans->TS_multiItem;
	  DBUnlock(trans);
	  }

	 /* do the void */
	 VoidTransaction(transSelected);

    /* re-draw the register */
    if (numTrans > DEFAULT_LIST_LINES-1)
	  @call RegisterDList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(numTrans);
    else
	  @call RegisterDList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(DEFAULT_LIST_LINES);
    @call RegisterDList::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(transSelected, FALSE);

    /* if it was a xfer we need to void the opposite trans in the
	* other account */
    if ((currentType == TRANS_XFP) || (currentType == TRANS_XFM)) {
	  mapPtr = DBLockMap(GPCBnkrFile);
	  acct = (AcctStruct *) (mapPtr + sizeof(DBMapStruct));
	  /* get the acct num of the xferGroup */
	  foundXferAccount = FALSE;
	  for (i = 0; i < numAccounts; i++)  {
		if (xferGroup == acct[i].AS_group)  {
		   xferAccount = i;
		   foundXferAccount = TRUE;
		   i = numAccounts;
		   }
		}
	  DBUnlock(mapPtr);
	  if (!foundXferAccount)  {
		NotifyDBox(0, @XferNoOppositeAcctMsg);
		return;
		}
	  /* now that we have the account num we can look for the trans
	   * in the sort array */
	  transListVMBHandle = VMFind(GPCBnkrFile, NullHandle, (xferAccount*10)+ALLSORT);
	  VMLock(GPCBnkrFile, transListVMBHandle ,&indexMH);
	  numXferTrans = ChunkArrayGetCountHandles(indexMH, transListChunkArray);
	  foundXferSelection = FALSE;
	  for (i = 0; i < numXferTrans; i++)  {
		trArrayElement = ChunkArrayElementToPtrHandles(
				indexMH,
				transListChunkArray,
				i,
				0);
		if (xferItem == trArrayElement->TSS_item)  {
		   xferSelection = i;
		   foundXferSelection = TRUE;
		   i = numXferTrans;
		   }
		}
	  VMUnlock(indexMH);
	  if (!foundXferSelection)  {
		NotifyDBox(0, @XferNoOppositeTransMsg);
		return;
		}
	  /* We now have the opposite acctNum, numTrans, and array element#
	   * we can now call the delete trans function with this info
	   */
	  /* save the globals */
	  saveAccount = currentAcct;
	  saveNumTrans = numTrans;
	  /* put in opposite account info */
	  currentAcct = xferAccount;
	  numTrans = numXferTrans;
	  /* do the delete */
	  VoidTransaction(xferSelection);
	  /* restore the globals */
	  currentAcct = saveAccount;
	  numTrans = saveNumTrans;
	  }


}

/***********************************************************************
 *
 * MESSAGE:	MSG_DELETE_TRANS for GPCBnkrProcessClass
 *
 * DESCRIPTION:	deletes a previously entered transaction
 *
 * STRATEGY:
 *
 *
 ***********************************************************************/

@extern method GPCBnkrProcessClass, MSG_DELETE_TRANS
{
TransSortStruct	*trArrayElement;
MemHandle			indexMH;
TransStruct		*trans;
DBGroup			xferGroup;
DBItem			transItem, xferItem;
word			     i, xferAccount, xferSelection, numXferTrans;
word			     saveAccount, saveNumTrans;
AcctStruct		*acct;
DBMapStruct*		mapPtr;
Boolean             foundXferAccount, foundXferSelection;


    /* put up an Are you sure box */
    if (AckDBox(0, 0, @DelTransMsg) == ACK_NO) return;

    /* need to see if this is a transfer */
    transListVMBHandle = VMFind(GPCBnkrFile, NullHandle, (currentAcct*10)+ALLSORT);
    VMLock(GPCBnkrFile, transListVMBHandle ,&indexMH);
    trArrayElement = ChunkArrayElementToPtrHandles(
		   indexMH,
		   transListChunkArray,
		   transSelected,
		   0);
    currentType = trArrayElement->TSS_type;
    transItem = trArrayElement->TSS_item;
    VMUnlock(indexMH);
    if ((currentType == TRANS_XFP) || (currentType == TRANS_XFM)) {
	  /* grab the opposite's Group and Item */
	  trans = DBLock(GPCBnkrFile, currentAcctGroup, transItem);
	  xferGroup = trans->TS_multiGroup;
	  xferItem = trans->TS_multiItem;
	  DBUnlock(trans);
	  }

    /* do the delete */
    DeleteTransaction(transSelected);

    /* re-draw the register */
    if (numTrans > DEFAULT_LIST_LINES-1)
	  @call RegisterDList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(numTrans);
    else
	  @call RegisterDList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(DEFAULT_LIST_LINES);
    @call RegisterDList::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(transSelected, FALSE);

    if (!numTrans)  {
	  /* disable buttons */
	  @send ModifyButton::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	  @send EntriesModifyMenuItem::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	  @send EntriesDeleteMenuItem::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	  @send EntriesVoidMenuItem::MSG_GEN_SET_NOT_ENABLED(VUM_DELAYED_VIA_APP_QUEUE);
	  }

    /* if it was a xfer we need to delete the opposite trans in the
	* other account */
    if ((currentType == TRANS_XFP) || (currentType == TRANS_XFM)) {
	  mapPtr = DBLockMap(GPCBnkrFile);
	  acct = (AcctStruct *) (mapPtr + sizeof(DBMapStruct));
	  /* get the acct num of the xferGroup */
	  foundXferAccount = FALSE;
	  for (i = 0; i < numAccounts; i++)  {
		if (xferGroup == acct[i].AS_group)  {
		   xferAccount = i;
		   foundXferAccount = TRUE;
		   i = numAccounts;
		   }
		}
	  DBUnlock(mapPtr);
	  if (!foundXferAccount)  {
		NotifyDBox(0, @XferNoOppositeAcctMsg);
		return;
		}
	  /* now that we have the account num we can look for the trans
	   * in the sort array */
	  transListVMBHandle = VMFind(GPCBnkrFile, NullHandle, (xferAccount*10)+ALLSORT);
	  VMLock(GPCBnkrFile, transListVMBHandle ,&indexMH);
	  numXferTrans = ChunkArrayGetCountHandles(indexMH, transListChunkArray);
	  foundXferSelection = FALSE;
	  for (i = 0; i < numXferTrans; i++)  {
		trArrayElement = ChunkArrayElementToPtrHandles(
				indexMH,
				transListChunkArray,
				i,
				0);
		if (xferItem == trArrayElement->TSS_item)  {
		   xferSelection = i;
		   foundXferSelection = TRUE;
		   i = numXferTrans;
		   }
		}
	  VMUnlock(indexMH);
	  if (!foundXferSelection)  {
		NotifyDBox(0, @XferNoOppositeTransMsg);
		return;
		}
	  /* We now have the opposite acctNum, numTrans, and array element#
	   * we can now call the delete trans function with this info
	   */
	  /* save the globals */
	  saveAccount = currentAcct;
	  saveNumTrans = numTrans;
	  /* put in opposite account info */
	  currentAcct = xferAccount;
	  numTrans = numXferTrans;
	  /* do the delete */
	  DeleteTransaction(xferSelection);
	  /* restore the globals */
	  currentAcct = saveAccount;
	  numTrans = saveNumTrans;
	  }

}

/***********************************************************************
 *
 * MESSAGE:		MSG_MODIFY_TRANS for GPCBnkrProcessClass
 *
 * DESCRIPTION:	modifies a previously entered transaction
 *
 * STRATEGY:        just deletes the old and enters the new
 *
 *
 ***********************************************************************/
@extern method GPCBnkrProcessClass, MSG_MODIFY_TRANS
{
char		dateString[DATE_SIZE];
char		amtInString[DOLLAR_IN_SIZE];



	  /* moved from opening so that user can review multis - it's the only
		* way to get a good look at multis */
	  /* if cleared tell the user no */
	  if (!CanModify) {
		NotifyDBox(0, @CantModClearedMsg);
		return;
		}


	 @call NEFDDate::MSG_VIS_TEXT_GET_ALL_PTR(dateString);
    @call NEFDAmount::MSG_VIS_TEXT_GET_ALL_PTR(amtInString);

    /* Exit if no amount */
    if (*amtInString == 0) {
	  NotifyDBox(0, @NoAmountMsg);
	  @send NEFDAmount::MSG_META_GRAB_FOCUS_EXCL();
	  return;
	  }

    /* Exit if amount invalid */
    if (!AmountChecksOK(amtInString, FALSE, FALSE))  {
	  /* send the focus back to the balance field */
	  @send NEFDAmount::MSG_META_GRAB_FOCUS_EXCL();
	  return;
	  }

    /* Exit if date no good */
    if (!DateCheck(dateString))  {
	  /* send the focus back to the date field */
	  @send NEFDDate::MSG_META_GRAB_FOCUS_EXCL();
	  return;
	  }

    /* do the delete */
    DeleteTransaction(transSelected);

    /* and add the changed trans */
    @call process::MSG_ENTER_TRANS();

}

/***********************************************************************
 *
 * MESSAGE:	MSG_VIS_CLOSE() for GPCBnkrEntryInteractionClass
 *
 * DESCRIPTION:	clears the fields in the new/mod Entry dbox.
 *                    & decrements the formUp global
 * PARAMETERS:
 *
 *
 ***********************************************************************/
@method GPCBnkrEntryInteractionClass, MSG_VIS_CLOSE
{

    /* clear the fields */
    @send NEFDAmount::MSG_VIS_TEXT_DELETE_ALL();
    @send NEFPayText::MSG_VIS_TEXT_DELETE_ALL();
    @send NEFMemoText::MSG_VIS_TEXT_DELETE_ALL();
    @send NEFCatText::MSG_VIS_TEXT_DELETE_ALL();
    @call NEFTax::MSG_GEN_BOOLEAN_GROUP_SET_GROUP_STATE(0, 0);

    if (multiFlag)  {
	  multiFlag = FALSE;
	  FLOAT_SET_FLOATNUM_TO_0(multiAmount);
	  MemFree(multiHeapHandle);
	  }

    formUp--;

    /* and if for some reason the user has left the CreateMultiDB open... */
    @send MultiDBox::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);

    /* and if the cat/pay DBs are up check to see if we need to disable
	* the Use buttons */
    if (!formUp) {
	  @send PayUse::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
	  @send CatUse::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
	  }

    @callsuper(); 
}

/***********************************************************************
 *
 * MESSAGE:	MSG_VIS_DRAW() for GPCBnkrEntryInteractionClass
 *
 * DESCRIPTION:	draws the background
 *
 * PARAMETERS:
 *	void(word drawFlags, GStateHandle gstate)
 *
 ***********************************************************************/
/*@method GPCBnkrEntryInteractionClass, MSG_VIS_DRAW
{

    GrSaveState(gstate);
    BankerDrawBitmap(gstate, formBitmap, 3, 56);
    GrRestoreState(gstate);
    @callsuper();

}

/***********************************************************************
 *
 * MESSAGE:	MSG_VIS_RECALC_SIZE() for TaxGenBooleanClass
 *
 * DESCRIPTION:	makes the check box narrower
 *                  and lets teh bkground show thru the visMoniker
 * PARAMETERS:
 *
 *
 ***********************************************************************/
@extern method TaxGenBooleanClass, MSG_VIS_RECALC_SIZE
{
SizeAsDWord		size;
word				superHeight;


	 size = @callsuper();

	 /* extract the superclass computed height */
	 superHeight = DWORD_HEIGHT(size);
	 /* use extracted height and our width */
	 return(MAKE_SIZE_DWORD(14, 11 /*(superHeight - 8)*/));

}

/***********************************************************************
 *
 * MESSAGE:	MSG_META_KBD_CHAR for AmountGenTextClass
 *
 * PARAMETERS:   	char		character
 *
 * DESCRIPTION:	traps the - and + signs
 *
 *
 *
 ***********************************************************************/
@extern method AmountGenTextClass, MSG_META_KBD_CHAR
{
char		string[DOLLAR_IN_SIZE];


    if ((oself == @NABalance) || (oself == @RCBegin) || (oself == @RCEnd)) {
	  /* these can be neg amounts */
	  if ((character == C_PLUS) &&
	      (flags & (CF_FIRST_PRESS | CF_REPEAT_PRESS))) return;
	  else  @callsuper();
	  }
    else {
       /* the rest cannot be neg */
	  if (((character == C_MINUS) || (character == C_PLUS)) &&
	      (flags & (CF_FIRST_PRESS | CF_REPEAT_PRESS))) return;
	  else if (oself == @AddMCatAmount){
          /* set the done/change buttons accordingly */
		if ((@call AddMCatAmount::MSG_VIS_TEXT_GET_ALL_PTR(string)) &&
		    (selMCat != GIGS_NONE)) {
		   @send AddMCatDone::MSG_GEN_SET_ENABLED(VUM_NOW);
		   @send AddMCatChange::MSG_GEN_SET_ENABLED(VUM_NOW);
		   }
		else {
		   @send AddMCatDone::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
		   @send AddMCatChange::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
		   }
		@callsuper();
		}
	  else  @callsuper;

	  }

}


