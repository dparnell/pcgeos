// browser.c - Sample to test buildof all ECMA and Browser objects

/* (c) COPYRIGHT 1993-98           NOMBAS, INC.
 *                                 64 SALEM ST.
 *                                 MEDFORD, MA 02155  USA
 *
 * ALL RIGHTS RESERVED
 *
 * This software is the property of Nombas, Inc. and is furnished under
 * license by Nombas, Inc.; this software may be used only in accordance
 * with the terms of said license.  This copyright notice may not be removed,
 * modified or obliterated without the prior written permission of Nombas, Inc.
 *
 * This software is a Trade Secret of Nombas, Inc.
 *
 * This software may not be copied, transmitted, provided to or otherwise made
 * available to any other person, company, corporation or other entity except
 * as specified in the terms of said license.
 *
 * No right, title, ownership or other interest in the software is hereby
 * granted or transferred.
 *
 * The information contained herein is subject to change without notice and
 * should not be construed as a commitment by Nombas, Inc.
 */

/* we need this for the callbacks... */
#pragma option -WDE

@include <stdapp.goh>

#include <Ansi/stdlib.h>
#include <Ansi/string.h>

@include "htmlview.goh"
#include "javascr.h"
#include <Internal/netutils.h>
#include <cookies.h>
#include <initfile.h>

#ifdef DO_DBCS
#define STRLENSB(s) strlensbcs(s)
Boolean NamePoolInitializeDynamicDOS(TCHAR *b, word sb, char *s, TCHAR **p)
{
    MemHandle mH;
    TCHAR *mP;
    word bLen, status, backup;
    DosCodePage cp = G_codePage;
    Boolean ret = FALSE;

    bLen = strlensbcs(s)+1;
    mH = MemAlloc(bLen*sizeof(TCHAR), HF_DYNAMIC, HAF_STANDARD);
    if (mH) {
	mP = MemLock(mH);
	LocalDosToGeos(mP, s, &bLen, DEFCHAR, &cp, 0, &status, &backup);
	ret = NamePoolInitializeDynamic(b, sb, mP, p);
	MemFree(mH);
    }
    return ret;
}
#define STRSTRSB(s,t) strstrsbcs(s,t)
void LocalUpcaseStringSBCS(char *s, word n)
{
    int i;

    if (!n) n = strlensbcs(s);
    for (i = 0; i < n; i++) {
	s[i] = toupper(s[i]);
    }
}
#define ATOISB(s) atoisbcs(s)
#define STRCPYSB(s,t) strcpysbcs(s,t)
char *G2D(TCHAR *s)
{
    DosCodePage cp = G_codePage;
    word len, status, backup;

    len = strlen(s)+1;
    LocalGeosToDos(s, s, &len, DEFCHAR, &cp, 0, &status, &backup);
    return (char *)s;
}
#else
#define STRLENSB(s) strlen(s)
#define NamePoolInitializeDynamicDOS(b, sb, s, p) NamePoolInitializeDynamic(b, sb, s, p)
#define STRSTRSB(s,t) strstr(s,t)
#define LocalUpcaseStringSBCS(s,n) LocalUpcaseString(s,n)
#define ATOISB(s) atoi(s)
#define STRCPYSB(s,t) strcpy(s,t)
#define G2D(s) s
#endif

@extern object URLText;


@ifdef JAVASCRIPT_SUPPORT

@extern chunk MsgScriptError;
@extern chunk MsgRunawayScript;

@extern object NavigateLoadGraphics;

@extern object HTMLVApp;
@extern object HTMLVPrimary;
@extern object HTMLDocumentGroup;

/* The -dc option causes us problems with function lists and other constants */
#pragma option -dc-

/* Disable warnings about unused parameters - we know we have many... */
#pragma warn -par


/* A reference to "the" global JS context */
jseContext jsecontext;

/* dynamically created images */
extern optr imageHeap;
/* dynamically created option elements */
extern optr optionHeap;
extern optr browserFrameObj;

@ifdef COMPILE_OPTION_AUTO_BROWSE
@extern object AutoBrowseOptions;
//#define GETDEFAULTSTATUS 0
//#define SETDEFAULTSTATUS 1
//#define GETSTATUS 2
//#define SETSTATUS 3
#define WINDOWBLUR 4
#define WINDOWFOCUS 5
#define WINDOWCLOSE 6
//#define WINDOWSCROLL 7
#define SETLOCATION 8
//#define SETDOCUMENTCOLOR 9
#define GETDOCUMENTCOLOR 10
#define DOCUMENTOPEN 11
#define DOCUMENTWRITE 12
#define DOCUMENTCLOSE 13
#define GETCOOKIE 14
#define SETCOOKIE 15
#define GETLASTMODIFIED 16
//#define GETREFERRER 17
#define SETFORM 18
#define ELEMENTSELECT 19
#define SETELEMENT 20
#define SETTIMEOUT 21
#define CLEARTIMEOUT 22
#define WINDOWMOVETO 23
#define WINDOWMOVEBY 24

#define LASTONE 25
/* zero-initialized by compiler */
static word unsupportedFeatures[LASTONE];
void ClearUnsupportedFeatures()
{
    memset(unsupportedFeatures, 0, LASTONE*(sizeof(word)));
}
#define LogUnsupported(s, n) if ((@call AutoBrowseOptions::MSG_GEN_BOOLEAN_GROUP_GET_SELECTED_BOOLEANS() & AB_OPTION_LOG_UNSUPPORTED_JS) && unsupportedFeatures[n]==0) {ABLog("unsupported: %s\r\n", s); unsupportedFeatures[n]++;};
@else
#define LogUnsupported(s, n)
@endif

/* runaway script timer */
dword startInterpret;
word runawayCount = 0;

extern TCHAR *getDialogString(const char *str, MemHandle *han);


/******************************************************************
************************** JS RELATED UI **************************
 ******************************************************************/

/* these should go in HTMLV_UI.GOH, but it is getting too big, as to
   crash the tools */

@start WindowOpenUIResource;

@object WindowOpenInteractionClass WindowOpenWindow = {
    GI_states = @default & ~GS_USABLE;
    GI_comp = @WindowOpenTop, @WindowOpenClose;
    GII_visibility = GIV_DIALOG;
    GII_attrs = @default  | GIA_NOT_USER_INITIATABLE | GIA_MODAL;
    HINT_INTERACTION_MAKE_RESIZABLE;
    HINT_KEEP_INITIALLY_ONSCREEN;
    HINT_KEEP_ENTIRELY_ONSCREEN;
    ATTR_GEN_HELP_CONTEXT = "TOC";
}

@object GenTriggerClass WindowOpenClose = {
    GI_visMoniker = "Close";
    GI_attrs = @default | GA_SIGNAL_INTERACTION_COMPLETE;
    HINT_SEEK_REPLY_BAR;
    ATTR_GEN_TRIGGER_INTERACTION_COMMAND = IC_DISMISS;
}

@object GenInteractionClass WindowOpenTop = {
}

@end WindowOpenUIResource;

@start WindowOpenFrameResource;

@object URLFrameClass WindowOpenFrame = {
}

@end WindowOpenFrameResource;

@classdecl WindowOpenInteractionClass;

@method WindowOpenInteractionClass, MSG_VIS_CLOSE
{
    NameToken url;

    @callsuper();
    /* just load empty page (single frame) to clear out memory usage and
       JS context, etc. */
    url = NamePoolTokenize(namePool, _TEXT("about:blank"), TRUE);
    @send, forceQueue WindowOpenFrame::MSG_URL_FRAME_FETCH_URL_AND_RELEASE(url, DIR_GO, NullHandle, NAME_POOL_NONE);
}

/******************************************************************
 ********************* BROWSER STUB FUNCTIONS *********************
 ******************************************************************/

/* Return the top (active) window. */
struct BrowserWindow *browserGetTopWindow(jseContext jsecontext,
                                          struct BrowserWindow *current_window)
{
    optr parent = (optr)current_window;

    /* traverse up to top (to handle HelpWindow, etc.) */
    while (1) {
	parent = @call (optr)current_window::MSG_URL_FRAME_FIND_PARENT();
	if (parent) {
	    current_window = (struct BrowserWindow *)parent;
	} else {
	    break;
	}
    }
    return current_window;
}


/* Return the parent of this window, or self if this is a top-level window. */
struct BrowserWindow *browserGetParentWindow(jseContext jsecontext,
                                             struct BrowserWindow *current_window)
{
    optr parent = @call (optr)current_window::MSG_URL_FRAME_FIND_PARENT();

    /* return self if top */
    if (!parent) {
	parent = (optr)current_window;
    } else {
	/* match IE behavior of skipping framesets */
	optr topFrame = (optr)browserGetTopWindow(jsecontext, current_window);
	/* skip up to frame level 0, as non-zero is nested frameset within
	   same HTML file (i.e. within same frame) */
	while ((parent != topFrame) &&
	       (@call parent::MSG_URL_FRAME_GET_FRAME_LEVEL()) /*&&
	       !((@call parent::MSG_URL_FRAME_GET_STATE()) & FS_ACTIVE)*/) {
	    /* no need to check FS_ACTIVE */
	    parent = @call parent::MSG_URL_FRAME_FIND_PARENT();
	}
    }
    return (struct BrowserWindow *)parent;
}

/* Return the window that called 'open()' to open this window, or NULL if
 * none did (this is the only window for example.)
 */
struct BrowserWindow *browserGetOpenerWindow(jseContext jsecontext,
                                             struct BrowserWindow *current_window)
{
    return (struct BrowserWindow *)(@call (optr)current_window::MSG_URL_FRAME_GET_OPENER());
}


/* Return the window's name */
NameToken browserGetNameOfWindow(jseContext jsecontext,
                                 struct BrowserWindow *current_window)
{
    return @call (optr)current_window::MSG_URL_FRAME_GET_NAME();
}


NameToken LOCAL IbrowserGetStatus(
               jseContext jsecontext,
               struct BrowserWindow *current_window,
               HTMLStatusType type)
{
    NameToken token = NAME_POOL_NONE ;
    struct BrowserDocument *document ;
    TCHAR status[200] ;

    document = browserGetDocument(jsecontext, current_window) ;
    if (document)  {
        /* Grab the status */
        @CallStatusGet(type, status, sizeof(status)-1*sizeof(TCHAR)) ;
        token = NamePoolTokenize(namePool, status, FALSE);
    }

    return token ;
}

void LOCAL IbrowserSetStatus(
               const jsecharptr text,
               HTMLStatusType type)
{
@ifdef UPDATE_ON_UI_THREAD
    MemHandle mh;

    /* If we are updating the status on a different thread, we copy
       the text into a "floating" memory block and send the message
       so it can be processed asynchronously. At the same time, this
       deals with cases where the text may reside in mapped block that
       could be paged out in another thread. */
@ifdef DO_DBCS
    TCHAR *p;
    word len = strlensbcs(text)+1;  /* include null */
    DosCodePage cp = G_codePage;
    word status, backup;

    mh = MemAlloc(len*sizeof(TCHAR), HF_DYNAMIC, HAF_STANDARD);
    if (!mh) return;
    p = MemLock(mh);
    LocalDosToGeos(p, text, &len, DEFCHAR, &cp, 0, &status, &backup);
@else
    mh = MemAlloc(strlen(text)+1, HF_DYNAMIC, HAF_STANDARD_NO_ERR_LOCK);
    strcpy(MemDeref(mh), text);
@endif
    MemUnlock(mh);
    @SendStatusUpdateBlock(mh, type);
@else
@ifdef DO_DBCS
    MemHandle mh;
    TCHAR *p;
    word len = strlensbcs(text)+1;  /* include null */

    mh = MemAlloc(len*sizeof(TCHAR), HF_DYNAMIC, HAF_STANDARD);
    if (!mh) return;
    p = MemLock(mh);
    cp = G_codePage;
    LocalDosToGeos(p, text, &len, DEFCHAR, &cp, 0, &status, &backup);
    @CallStatusUpdate(text, type) ;
    MemFree(mh);
@else
    @CallStatusUpdate(text, type) ;
@endif
@endif
}

/* Get the default value of the status line for this window */
NameToken browserGetDefaultStatus(jseContext jsecontext,
                                  struct BrowserWindow *current_window)
{
    return IbrowserGetStatus(jsecontext, current_window, HTML_STATUS_TYPE_JAVASCRIPT_DEFAULT) ;
}


/* Set the default value of the status line for this window */
void browserSetDefaultStatus(jseContext jsecontext,
                             struct BrowserWindow *current_window,
                             const jsecharptr text)
{
    IbrowserSetStatus(text, HTML_STATUS_TYPE_JAVASCRIPT_DEFAULT) ;
}

/* Get the current value of the status line for this window. */
NameToken browserGetStatus(jseContext jsecontext,
                           struct BrowserWindow *current_window)
{
    return IbrowserGetStatus(jsecontext, current_window, HTML_STATUS_TYPE_JAVASCRIPT) ;
}


/* Set the current value of the status line for this window */
void browserSetStatus(jseContext jsecontext,
                      struct BrowserWindow *current_window,
                      const jsecharptr text)
{
    IbrowserSetStatus(text, HTML_STATUS_TYPE_JAVASCRIPT) ;
}


/*
 * build complete frame list within one HTML file,
 * using depth-first search
 */
void browserGetFrameList(jseContext jsecontext,
			 struct BrowserWindow *parent,
			 optr *list)
{
    word n, i;
    optr child, *leaf;
    WordFlags state;

    n = @call (optr)parent::MSG_URL_FRAME_COUNT_CHILDREN();
    for (i = 0; i < n; i++) {
	child = @call (optr)parent::MSG_URL_FRAME_FIND_CHILD(i);
	/* stop at first active dummy frame */
	state = @call child::MSG_URL_FRAME_GET_STATE();
	if ((state & (FS_ACTIVE | FS_DUMMY)) != FS_ACTIVE) {
	    break;
	}
	/* only handle non-top-level frames */
	if ((@call child::MSG_URL_FRAME_GET_FRAME_LEVEL()) &&
	    (@call child::MSG_URL_FRAME_GET_FRAME_FLAGS() & HTML_FRF_FRAMESET) &&
	    @call child::MSG_URL_FRAME_COUNT_CHILDREN()) {
	    browserGetFrameList(jsecontext, (struct BrowserWindow *)child, list);
	    break;
	}
	leaf = ChunkArrayAppend(*list, sizeof(optr));
	*leaf = child;
    }
}

/* These routine is called to retrieve the frames under a parent window. It
 * is initially called with NULL as the last_child, then is called iteratively
 * with the last_child being the last returned window. You return the first
 * (if NULL) else the next window in the list of frames. You return NULL when
 * there are no more frames (the first window can be NULL if there are no frames.)
 */
struct BrowserWindow *browserGetNextFrame(jseContext jsecontext,
                                          struct BrowserWindow *parent,
                                          struct BrowserWindow *last_child)
{
    word n,i;
    optr child, last, ret;
    WordFlags state;

    last = ret = NullOptr;              // nothing found
    n = @call (optr)parent::MSG_URL_FRAME_COUNT_CHILDREN();
    for(i=0; i<n; i++)
    {
      child = @call (optr)parent::MSG_URL_FRAME_FIND_CHILD(i);
      if(last==(optr)last_child)        // just passed child before target?
      {
        ret = child;                    // yes: we have a winner
        break;
      }
      last = child;                     // remember previous child
    }

    if(ret)                             // test if hit is active and no dummy
    {
      state = @call ret::MSG_URL_FRAME_GET_STATE();
      if( (state & (FS_ACTIVE | FS_DUMMY)) != FS_ACTIVE )
        ret = NullOptr;                 // ...otherwise we're done, too
    }

    return (struct BrowserWindow *)ret;
}


/* Return the location magic cookie for this window */
struct BrowserLocation *browserGetLocation(jseContext jsecontext,
                                           struct BrowserWindow *current_window)
{
    /* A "regular" optr indicates that it is for a window's location */
    return (struct BrowserLocation *)current_window;
}


/* Return the document magic cookie for this window */
struct BrowserDocument *browserGetDocument(jseContext jsecontext,
                                           struct BrowserWindow *current_window)
{
    /* We don't really make a difference between "window" and "document",
       as both are mapped to non-dummy URLFrame objects. */
    return (struct BrowserDocument *)current_window;
}


#pragma codeseg BrowserJSRare
#pragma option -dc-

/* Dialog utility routine */
void browserDialog(TCHAR *msg, TCHAR *arg1, TCHAR *arg2, CustomDialogBoxFlags flags)
{
    MemHandle strBlock;
    TCHAR *m;
    word mLen, len1 = 0, len2 = 0, offset1 = 0, offset2 = 0;
@ifdef DO_DBCS
    DosCodePage cp = G_codePage;
    word status, backup;
@endif

    mLen = STRLENSB(msg)+1;  /* include null */
    if (arg1) {
	len1 = STRLENSB(arg1)+1;  /* include null */
	offset1 = mLen;
    }
    if (arg2) {
	len2 = STRLENSB(arg2)+1;  /* include null */
	offset2 = mLen+len1;
    }
    strBlock = MemAlloc(mLen*sizeof(TCHAR) + len1*sizeof(TCHAR) + len2*sizeof(TCHAR), HF_DYNAMIC, HAF_STANDARD);
    if (strBlock) {
	m = MemLock(strBlock);
@ifdef DO_DBCS
        LocalDosToGeos(m, msg, &mLen, DEFCHAR, &cp, 0, &status, &backup);
        cp = G_codePage;
        if (arg1) LocalDosToGeos(m+offset1*sizeof(TCHAR), arg1, &len1, DEFCHAR, &cp, 0, &status, &backup);
        cp = G_codePage;
        if (arg2) LocalDosToGeos(m+offset2*sizeof(TCHAR), arg2, &len2, DEFCHAR, &cp, 0, &status, &backup);
@else
	strcpy(m, msg);
	if (arg1) strcpy(m+offset1, arg1);
	if (arg2) strcpy(m+offset2, arg2);
@endif
	MemUnlock(strBlock);
	/* process through our queue to hold up until script finishes,
	   to reduce memory load */
	@send, forceQueue process::MSG_HMLVP_STANDARD_DIALOG(strBlock, offset1, offset2, flags);
    }
}

/* Display an alert (modal as other browsers do)
 */
void browserDisplayAlertDialog(jseContext jsecontext,
                               struct BrowserWindow *current_window,
                               const jsecharptr msg)
{
    char *p;
    MemHandle pH;

    /* use blocking dialog, as other browsers do */
    p = getDialogString(msg, &pH);
    if (!p) return;
    UserStandardDialog(0, 0, 0, 0,
		       p,
		       (CDT_NOTIFICATION << CDBF_DIALOG_TYPE_OFFSET) |
		       (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET));
    if (pH)
	MemFree(pH);
    /* reset script timer after blocking alert dialog */
    startInterpret = TimerGetCount();
}

@start JavascriptDialogResource;
@object GenInteractionClass JavascriptPromptDialog = {
    GI_visMoniker = "User Prompt";
    GII_visibility = GIV_DIALOG;
    GII_type = GIT_COMMAND ;
    GII_attrs = @default | GIA_NOT_USER_INITIATABLE
                         | GIA_INITIATED_VIA_USER_DO_DIALOG
                         | GIA_MODAL;
    GI_comp =
        @JavascriptPromptMessage,
        @JavascriptPromptText,
        @JavascriptPromptOK ;
    GI_states = (@default) & ~GS_USABLE;
}

@object GenTextClass JavascriptPromptMessage = {
    GI_attrs = @default | GA_READ_ONLY;
    GTXI_text = "?" ;
    HINT_FIXED_SIZE = {
	SST_AVG_CHAR_WIDTHS | 50,
	0,
	0
    };
}
@object GenTextClass JavascriptPromptText = {
    GTXI_text = "" ;
    GTXI_attrs = @default | GTA_SINGLE_LINE_TEXT;
    HINT_FIXED_SIZE = {
	SST_AVG_CHAR_WIDTHS | 50,
	0,
	0
    };
}
@object GenTriggerClass JavascriptPromptOK = {
    GI_attrs = @default | GA_SIGNAL_INTERACTION_COMPLETE;
    HINT_SEEK_REPLY_BAR;
    ATTR_GEN_TRIGGER_INTERACTION_COMMAND = IC_OK;
    HINT_DEFAULT_DEFAULT_ACTION;
}

@end JavascriptDialogResource;

@start JSUIResource;

@visMoniker QOKMoniker = "OK";
@visMoniker QCancelMoniker = "Cancel";

@end JSUIResource;

NameToken browserWindowPrompt(
              jseContext jsecontext,
              struct BrowserWindow *win,
              const jsecharptr msg,
              const jsecharptr def,
              Boolean *didCancel)
{
    NameToken token = NAME_POOL_NONE ;
    MemHandle mem ;
    TCHAR *p_text ;
    optr dialog ;
    optr msgObj ;
    optr textObj ;
@ifdef DO_DBCS
    MemHandle msgH, defH;
    TCHAR *msgP, *defP;

    msgP = getDialogString(msg, &msgH);
    defP = getDialogString(def, &defH);
    if (!msgP) return token;
    if (!defP) return token;
@endif

    /* Add dialog */
    dialog = UserCreateDialog(@JavascriptPromptDialog) ;
    msgObj = ConstructOptr(
                OptrToHandle(dialog),
                OptrToChunk(@JavascriptPromptMessage)) ;
    textObj = ConstructOptr(
                OptrToHandle(dialog),
                OptrToChunk(@JavascriptPromptText)) ;
@ifdef DO_DBCS
    @call msgObj::MSG_VIS_TEXT_REPLACE_ALL_PTR(msgP, 0) ;
    @call textObj::MSG_VIS_TEXT_REPLACE_ALL_PTR(defP, 0) ;
    MemFree(msgH);
    MemFree(defH);
@else
    @call msgObj::MSG_VIS_TEXT_REPLACE_ALL_PTR(msg, 0) ;
    @call textObj::MSG_VIS_TEXT_REPLACE_ALL_PTR(def, 0) ;
@endif
    if (UserDoDialog(dialog) == IC_DISMISS)  {
        *didCancel = TRUE ;
    } else {
        *didCancel = FALSE ;
        mem = @call textObj::MSG_VIS_TEXT_GET_ALL_BLOCK(NullHandle) ;
        if (mem)  {
            p_text = MemLock(mem) ;
            token = NamePoolTokenize(namePool, p_text, TRUE) ;
            MemFree(mem) ;
        }
    }
    UserDestroyDialog(dialog) ;
    return token ;
}

/* Display an alert with 'OK' and 'CANCEL' buttons and wait for a response
 * (i.e. it should be modal.) Return a boolean indicating whether 'OK'
 * was selected.
 */
jsebool browserDisplayQuestionDialog(jseContext jsecontext,
                                     struct BrowserWindow *current_window,
                                     const jsecharptr msg)
{
    word ret;
    TCHAR *p;
    MemHandle pH;
    StandardDialog2ResponseTriggerTable qTriggers = {
	2,
	{@QOKMoniker, IC_YES},
	{@QCancelMoniker, IC_NO}
    };

    p = getDialogString(msg, &pH);
    if (!p) return FALSE;
    ret = UserStandardDialog(
      0, (char*)&qTriggers, 0, 0, p,
      (CDT_QUESTION << CDBF_DIALOG_TYPE_OFFSET) |
        (GIT_MULTIPLE_RESPONSE << CDBF_INTERACTION_TYPE_OFFSET));
    if (pH)
	MemFree(pH);

    /* reset script timer after blocking confirm dialog */
    startInterpret = TimerGetCount();

    return (ret==IC_YES);
}


/* Make the given window lose the keyboard focus. If the window is a frame,
 * then give keyboard focus to the top level window containing the frame,
 * otherwise cycle the window to the bottom of the window stack.
 */
void browserBlurWindow(jseContext jsecontext,
                       struct BrowserWindow *current_window)
{
   /*** must implement ***/
   LogUnsupported("window.blur", WINDOWBLUR);
}


/* Give the keyboard focus to the given window. */
void browserGiveFocusToWindow(jseContext jsecontext,
                              struct BrowserWindow *current_window)
{
   /*** must implement ***/
   LogUnsupported("window.focus", WINDOWFOCUS);
}


/* Opens a new window and returns a handle to it. The url will always
 * be a string, but it may be blank (i.e. ""). The name and features arguments
 * will be NULL if not included. 'replace' defaults to False. Look up the
 * expected behavior in a Javascript book, as it is complex and lengthy.
 */
struct BrowserWindow *browserOpenWindow(jseContext jsecontext,
                                        struct BrowserWindow *opener,
                                        const jsecharptr url,
                                        const jsecharptr name,
                                        const jsecharptr features,
                                        jsebool replace,
					jsebool force)
{
    NameToken urlT, refererT, nameT = NAME_POOL_NONE;
    TCHAR urlbuf[HTML_STATIC_BUF], *urlP;
    optr docObj, field;
    SizeAsDWord maxSize;
    word width = 400, height = 300, maxWidth, maxHeight;
    char *featuresP;

    /* XXX: limited support -- open if launched from an event,
       but not if during embedded JS execution */
    /* BrowserWindow == BrowserLocation == URLFrame obj */
    /* only if close is not pending */
    if (force || @call (optr)opener::MSG_URL_FRAME_CAN_WINDOW_OPEN() ||
	/* or not top frame */
	@call (optr)opener::MSG_URL_FRAME_GET_FRAME_LEVEL()) {
	/* build full URL */
	if (!NamePoolInitializeDynamicDOS(urlbuf, sizeof(urlbuf), url, &urlP))
	    return (struct BrowserWindow *)NULL;
	@call (optr)opener::MSG_URL_FRAME_COMPLETE_URL(&urlP);
	urlT = NamePoolTokenize(namePool, urlP, TRUE);
	NamePoolDestroyIfDynamic(urlP);
	/* get referrer */
	refererT = @call (optr)opener::MSG_URL_FRAME_GET_URL();
	/* set up window.open window */
	field = @call application::MSG_GEN_FIND_PARENT();
	maxSize = @call field::MSG_VIS_GET_SIZE();
	maxWidth = (DWORD_WIDTH(maxSize) * 9)/10;
	maxHeight = (DWORD_HEIGHT(maxSize) * 7)/10;
	if ((@call HTMLVPrimary::MSG_GEN_FIND_CHILD(@WindowOpenWindow)) == 0xffff) {
	    @call HTMLVPrimary::MSG_GEN_ADD_CHILD(@WindowOpenWindow, CCO_LAST | CCF_MARK_DIRTY);
	    @call WindowOpenWindow::MSG_GEN_SET_USABLE(VUM_DELAYED_VIA_APP_QUEUE);
	    @call WindowOpenFrame::MSG_URL_FRAME_SET_INTERACTION_OBJ(@WindowOpenTop);
	    @call HTMLDocumentGroup::MSG_META_GET_MODEL_EXCL(&docObj);
	    @call WindowOpenFrame::MSG_URL_FRAME_SET_STATE(FS_ACTIVE, 0);
	    @call WindowOpenFrame::MSG_URL_FRAME_SET_DOCUMENT_OBJ(docObj);
	}
	/* get size from features, if any */
	if (features) {
	    LocalUpcaseStringSBCS(features, 0);
	    featuresP = STRSTRSB(features, "WIDTH");
	    if (featuresP) {
		featuresP += 5;
		while (*featuresP == ' ') featuresP++;
		if (*featuresP == '=') {
		    do featuresP++; while (*featuresP == ' ');  /* skips = first */
		    width = ATOISB(featuresP);
		    if (width > maxWidth) width = maxWidth;
		}
	    }
	    featuresP = STRSTRSB(features, "HEIGHT");
	    if (featuresP) {
		featuresP += 6;
		while (*featuresP == ' ') featuresP++;
		if (*featuresP == '=') {
		    do featuresP++; while (*featuresP == ' ');  /* skips = first */
		    height = ATOISB(featuresP);
		    if (height > maxHeight) height = maxHeight;
		}
	    }
	}
	@call WindowOpenTop::MSG_GEN_SET_FIXED_SIZE(VUM_DELAYED_VIA_APP_QUEUE, 0, height, width);
	@send WindowOpenWindow::MSG_GEN_RESET_TO_INITIAL_SIZE(VUM_DELAYED_VIA_APP_QUEUE);
	/* set window.opener */
	@call WindowOpenFrame::MSG_URL_FRAME_SET_OPENER((optr)opener);
	/* set window.name */
	if (name && *name) {
	    nameT = NamePoolTokenizeDOS(namePool, name, TRUE);
	}
	                           /* clears previously one if none */
	@call WindowOpenFrame::MSG_URL_FRAME_SET_NAME(nameT);
	if (nameT) {
	    NamePoolReleaseToken(namePool, nameT);  /* ref added by SET_... */
	}
	/* open window */
	@send WindowOpenWindow::MSG_GEN_INTERACTION_INITIATE();
	/* handler releases url and referer tokens */
	/* (no need to insertAtFront for this, I think) */
	@send, forceQueue WindowOpenFrame::
	    MSG_URL_FRAME_FETCH_URL_AND_RELEASE(urlT, DIR_GO, NullHandle, refererT);
	/* return the newly opened window */
	opener = (struct BrowserWindow *)(@WindowOpenFrame);
    } else {
	opener = NULL;  /* window.open ignored */
    }
    return (struct BrowserWindow *)opener;
}


/* Close the given window. In Netscape, only windows opened via Javascript
 * can be closed in this manner, and you may want to make the same rule.
 * Even though the window is closed, the magic cookie 'current_window' cannot
 * be discarded, but should be marked as 'closed'. These magic cookies
 * must remain until the browser exits.
 */
void browserCloseWindow(jseContext jsecontext,
                        struct BrowserWindow *current_window)
{
    if ((optr)current_window == @WindowOpenFrame) {
	@call WindowOpenWindow::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);
    }
}


/* This returns whether or not the given window has been closed. */
jsebool browserIsWindowClosed(jseContext jsecontext,
                              struct BrowserWindow *current_window)
{
   return FALSE; // currently, the user cannot close any windows
}


/* Scroll the given window to the given location. The coordinate system
 * is undefined (most likely in pixels), but 0,0 is the top-left corner.
 * Note that the given location is absolute, not relative.
 */
void browserScrollWindow(jseContext jsecontext,
                         struct BrowserWindow *current_window,
                         ulong x, ulong y)
{
    optr text,frame, view ;

    /* this would be easier without dummy frames... */
    text = @call (optr)current_window::MSG_URL_FRAME_FIND_TEXT_OBJECT();
    if (text)  {
        frame = @call text::MSG_URL_TEXT_GET_FRAME_OBJ();
        if (frame)  {
            view = @call frame::MSG_URL_FRAME_GET_INTERACTION_OBJ();
            if (view)  {
                @call view::MSG_GEN_VIEW_MAKE_RECT_VISIBLE(
                        MRVF_ALWAYS_SCROLL | MRVF_USE_MARGIN_FROM_TOP_LEFT,
                        0,
                        MRVF_ALWAYS_SCROLL | MRVF_USE_MARGIN_FROM_TOP_LEFT,
                        0,
                        y,
                        x,
                        y,
                        x) ;
            }
        }
    }
}


/* Move the given window to the given absolute location.
 */
void browserMoveWindowAbs(jseContext jsecontext,
                          struct BrowserWindow *current_window,
                          ulong x, ulong y)
{
   // currently ignored
   LogUnsupported("ignoring window.moveTo", WINDOWMOVETO);
}


/* Move the given window to the relative location.
 */
void browserMoveWindowRel(jseContext jsecontext,
			  struct BrowserWindow *current_window,
			  ulong x, ulong y)
{
   // currently ignored
   LogUnsupported("ignoring window.moveBy", WINDOWMOVEBY);
}


/* Like typing in a new URL in the window's URL entry field. If replace is TRUE,
 * then replace the history with the new document rather than appending it.
 */
void browserGotoURL(jseContext jsecontext,
                    struct BrowserLocation *location,
                    const jsecharptr url_text,
                    jsebool replace)
{
    NameToken url, referer;
    TCHAR urlbuf[HTML_STATIC_BUF], *urlP;

    if (!NamePoolInitializeDynamicDOS(urlbuf, sizeof(urlbuf), url_text, &urlP))
	return;
    @call (optr)location::MSG_URL_FRAME_COMPLETE_URL(&urlP);
    url = NamePoolTokenize(namePool, urlP, TRUE);
    NamePoolDestroyIfDynamic(urlP);
    referer = @call (optr)location::MSG_URL_FRAME_GET_URL();
    /* handler releases url and referer tokens */
    /* (no need to insertAtFront for this, I think) */
    @send, forceQueue (optr)location::MSG_URL_FRAME_FETCH_URL_AND_RELEASE(url,
      DIR_GO, NullHandle, referer);
}


/* Cause the given location to be reloaded, if it has been modified
 * since last load. If the 'force' boolean is true, reload it regardless.
 */
void browserReloadLocation(jseContext jsecontext,
                           struct BrowserLocation *location,
                           jsebool force,
                           jseVariable thisvar)
{
    @send,forceQueue,insertAtFront (optr)location::MSG_URL_FRAME_RELOAD();
}

#pragma codeseg
#pragma option -dc


/* Shortcut if only the URL itself is requested */
NameToken browserGetURL(jseContext jsecontext,
                        struct BrowserLocation *location,
                        NameToken *target)
{
    optr text, pool, frame;
    NameToken url;
    HTMLanchorData had;
    TCHAR linkBuf[HTML_STATIC_BUF], *linkP;

    if((word)OptrToChunk((optr)location) & 0x8000)
    {                                   // Is it a link location?
      text = ConstructOptr(OptrToHandle((optr)location), OptrToChunk(@URLText));
      pool = @call text::MSG_HTML_TEXT_GET_NAME_POOL();
      frame = @call text::MSG_URL_TEXT_GET_FRAME_OBJ();
      @call text::MSG_HTML_TEXT_GET_LINK((word)OptrToChunk((optr)location) & 0x7FFF,
        &had);
      NamePoolCopy(pool, linkBuf, sizeof(linkBuf), had.linkOrName, &linkP);
      @call frame::MSG_URL_FRAME_COMPLETE_URL(&linkP);
      url = NamePoolTokenize(namePool, linkP, FALSE);
      if(*target)
        *target = NamePoolTokenizeFromPool(namePool, pool, had.target, FALSE);
    }
    else                                // No, it's a window location
    {
      url = @call (optr)location::MSG_URL_FRAME_GET_URL();
      if(*target)
	*target = NAME_POOL_NONE;
    }

    return url;
}

/* Fill in the URL structure with the values for the given location */
void browserGetLocationValue(jseContext jsecontext,
                             struct BrowserLocation *location,
                             struct BrowserURLContents *fill_me_in)
{
    TCHAR urlbuf[HTML_STATIC_BUF], *urlP;
    MemHandle locH;
    TCHAR *locP, *miscP, *misc2P;

#define TYPE_OFFSET 0
#define SERVER_OFFSET URL_MAX_TYPE+1+1  /* room for ':' */
#define PATH_OFFSET SERVER_OFFSET+URL_MAX_SERVER+1

    fill_me_in->href = browserGetURL(jsecontext, location, &(fill_me_in->target));

    /* defaults */
    fill_me_in->protocol = NAME_POOL_NONE;
    fill_me_in->hostname = NAME_POOL_NONE;
    fill_me_in->port = NAME_POOL_NONE;
    fill_me_in->pathname = NAME_POOL_NONE;
    fill_me_in->search = NAME_POOL_NONE;
    fill_me_in->hash = NAME_POOL_NONE;
    fill_me_in->host = NAME_POOL_NONE;

    /* should pass something in here to allow this to be a bit more specific,
       instead of computing everything each time */
    if (fill_me_in->href != NAME_POOL_NONE) {
	NamePoolCopy(namePool, urlbuf, sizeof(urlbuf), fill_me_in->href, &urlP);
	locH = MemAlloc((URL_MAX_TYPE+1+1 + URL_MAX_SERVER+1 + strlen(urlP)+1)*sizeof(TCHAR),
			HF_DYNAMIC, HAF_STANDARD);
	if (locH) {
	    locP = MemLock(locH);
	    ToolsParseURL(urlP, locP+TYPE_OFFSET, locP+SERVER_OFFSET, locP+PATH_OFFSET);
	    /* procotol, add ":" if non-zero */
	    if (strlen(locP+TYPE_OFFSET)) {
		strcat(locP+TYPE_OFFSET, _TEXT(":"));
	    }
	    fill_me_in->protocol = NamePoolTokenize(namePool, locP+TYPE_OFFSET, TRUE);
	    /* host (with port number) */
	    fill_me_in->host = NamePoolTokenize(namePool, locP+SERVER_OFFSET, TRUE);
	    /* hostname (without port number) and port */
	    miscP = strchr(locP+SERVER_OFFSET, _TEXT(':'));
	    if (miscP) {
		fill_me_in->port = NamePoolTokenize(namePool, miscP+1, TRUE);
		*miscP = C_NULL;
	    }
	    fill_me_in->hostname = NamePoolTokenize(namePool, locP+SERVER_OFFSET, TRUE);
	    /* pathname, search, hash */
	    miscP = strchr(locP+PATH_OFFSET, '?');
	    if (miscP) {
		misc2P = strchr(miscP, '#');
		if (misc2P) {
		    /* includes '#' */
		    fill_me_in->hash = NamePoolTokenize(namePool, misc2P, TRUE);
		    *misc2P = C_NULL;
		}
		/* includes '?' */
		fill_me_in->search = NamePoolTokenize(namePool, miscP, TRUE);
		*miscP = C_NULL;
	    }
	    fill_me_in->pathname = NamePoolTokenize(namePool, locP+PATH_OFFSET, TRUE);
	    MemFree(locH);
	}
	NamePoolDestroyIfDynamic(urlP);
    }
}


void browserSetLocationURL(jseContext jsecontext,
			   struct BrowserLocation *location,
			   const jsecharptr url_text,
			   const jsecharptr target_text,
			   jsebool replace)
{
    optr text;
    optr pool;
    HTMLanchorData had;

    if (location) {
	if (((word)OptrToChunk((optr)location) & 0x8000) == 0) {
	    browserGotoURL(jsecontext, location, url_text, replace);
	} else {
	    text = ConstructOptr(OptrToHandle((optr)location), OptrToChunk(@URLText));
	    pool = @call text::MSG_HTML_TEXT_GET_NAME_POOL();
	    @call text::MSG_HTML_TEXT_GET_LINK((word)OptrToChunk((optr)location) & 0x7FFF, &had);
	    /* only handle setting link.href and link.target */
	    if ((had.flags & (HTML_ADF_NAME | HTML_ADF_MAP)) == 0) {
		had.linkOrName = NamePoolTokenizeDOS(pool, url_text, FALSE);
		if (target_text && *target_text) {
		    had.target = NamePoolTokenizeDOS(pool, target_text, FALSE);
		}
		@call text::MSG_HTML_TEXT_SET_LINK((word)OptrToChunk((optr)location) & 0x7FFF, &had);
	    }
	}
    }
}

/* Change the given location to the values in the structure. This really
 * means change the location, so for example if the 'location' magic cookie
 * represents the window's current URL, the window must be updated to point
 * at the new URL. If the location is for a link, do what is appropriate.
 */
void browserSetLocationValue(jseContext jsecontext,
                             struct BrowserLocation *location,
                             struct BrowserURLContents *fill_me_in)

{
    /* not used for setting HREF */
    TCHAR protocolBuf[URL_MAX_TYPE+1], *protocolP;
    TCHAR hostnameBuf[64+1], *hostnameP;
    TCHAR portBuf[5+1], *portP;
    TCHAR pathnameBuf[HTML_STATIC_BUF+1], *pathnameP;
    TCHAR searchBuf[64+1], *searchP;
    TCHAR hashBuf[20+1], *hashP;
    TCHAR targetBuf[20+1], *targetP;
    MemHandle urlB;
    TCHAR *urlP;
#ifdef DO_DBCS
    word urlLen, status, backup;
    DosCodePage cp = G_codePage;
#endif

    /* get all parts, we'll get null-string for NAME_POOL_NONE */
    NamePoolCopy(namePool, protocolBuf, sizeof(protocolBuf), fill_me_in->protocol, &protocolP);
    NamePoolCopy(namePool, hostnameBuf, sizeof(hostnameBuf), fill_me_in->hostname, &hostnameP);
    NamePoolCopy(namePool, portBuf, sizeof(portBuf), fill_me_in->port, &portP);
    NamePoolCopy(namePool, pathnameBuf, sizeof(pathnameBuf), fill_me_in->pathname, &pathnameP);
    NamePoolCopy(namePool, searchBuf, sizeof(searchBuf), fill_me_in->search, &searchP);
    NamePoolCopy(namePool, hashBuf, sizeof(hashBuf), fill_me_in->hash, &hashP);
    NamePoolCopy(namePool, targetBuf, sizeof(targetBuf), fill_me_in->target, &targetP);

    /* build new URL and set it */
    urlB = MemAlloc((strlen(protocolP)+2+
		     strlen(hostnameP)+1+strlen(portP)+
		     strlen(pathnameP)+
		     strlen(searchP)+
		     strlen(hashP)+1)*sizeof(TCHAR),
		    HF_DYNAMIC, HAF_STANDARD_LOCK);
    if (urlB) {
	urlP = MemDeref(urlB);
	if (*protocolP) {
	    sprintf(urlP, _TEXT("%s//"), protocolP);
	}
	strcat(urlP, hostnameP);
	if (*portP) {
	    strcat(urlP, _TEXT(":"));
	    strcat(urlP, portP);
	}
	strcat(urlP, pathnameP);
	strcat(urlP, searchP);
	strcat(urlP, hashP);
#ifdef DO_DBCS
	urlLen = strlen(urlP)+1;
	LocalGeosToDos(urlP, urlP, &urlLen, DEFCHAR, &cp, 0, &status, &backup);
#endif
	browserSetLocationURL(jsecontext, location, urlP, targetP, FALSE);
	MemFree(urlB);
    }

    /* free any dynamic buffers */
    NamePoolDestroyIfDynamic(protocolP);
    NamePoolDestroyIfDynamic(hostnameP);
    NamePoolDestroyIfDynamic(portP);
    NamePoolDestroyIfDynamic(pathnameP);
    NamePoolDestroyIfDynamic(searchP);
    NamePoolDestroyIfDynamic(hashP);
    NamePoolDestroyIfDynamic(targetP);
}


/* Get the number of entries in the given window's history list. */
@extern object HistoryList;
ulong browserGetHistoryLength(jseContext jsecontext,
                              struct BrowserWindow *current_window)
{
   /* HistoryList and HistoryList2 have same stuff */
   return (ulong)(@call HistoryList::MSG_GEN_DYNAMIC_LIST_GET_NUM_ITEMS());
}


/* Go to a location relative to the current one. The offset species the location.
 * offset of '-1' means go back one, '1' means forward one, etc.
 */
void browserHistoryGo(jseContext jsecontext,
                      struct BrowserWindow *current_window,
                      long offset)
{
    optr doc = @call (optr)current_window::MSG_URL_FRAME_GET_DOCUMENT_OBJ();

    /* XXX: only supporting -1, 0, and 1 for now, no JS 1.1 substring either */
    if (doc) {
	if (offset == 0) {
	    @send, forceQueue, insertAtFront doc::MSG_URL_DOCUMENT_RELOAD();
	} else if ((slong)offset == -1) {
	    @send, forceQueue, insertAtFront doc::MSG_URL_DOCUMENT_BACK();
	} else if (offset == 1) {
	    @send, forceQueue, insertAtFront doc::MSG_URL_DOCUMENT_FORWARD();
	}
    }
}


NameToken browserGetHistoryItem(jseContext jsecontext,
                                struct BrowserWindow *current_window,
                                ulong itemnum)
{
   /*** XXX: for security purposes, do not return history strings ***/
   return NAME_POOL_NONE;
}


/* Fill in the Image structure with the information about the given image
 * magic cookie.
 */
void browserGetImage(jseContext jsecontext,
                     struct BrowserImage *image,
                     struct BrowserImageContents *fill_in)
{
    optr text;
    optr pool;
    HTMLimageData hid;
    word isize;

    if (OptrToHandle((optr)image) == OptrToHandle(imageHeap)) {
	/* fetch for dynamically created image */
	MemLock(OptrToHandle((optr)image));
	memcpy(fill_in, ChunkArrayElementToPtr(imageHeap,
					       (word)(OptrToChunk((optr)image)),
					       &isize), sizeof(struct BrowserImageContents));
	MemUnlock(OptrToHandle((optr)image));
	/* add reference for caller */
	if (fill_in->src != NAME_POOL_NONE)
	    NamePoolUseToken(namePool, fill_in->src);
	if (fill_in->lowsrc != NAME_POOL_NONE)
	    NamePoolUseToken(namePool, fill_in->lowsrc);
	if (fill_in->name != NAME_POOL_NONE)
	    NamePoolUseToken(namePool, fill_in->name);
    } else {
    text = ConstructOptr(OptrToHandle((optr)image), OptrToChunk(@URLText));
    pool = @call text::MSG_HTML_TEXT_GET_NAME_POOL();

    /* Get requested image from text object */
    @call text::MSG_HTML_TEXT_GET_IMAGE(OptrToChunk((optr)image), &hid);

    fill_in->border = 0;                // border property is not supported
    fill_in->lowsrc = NAME_POOL_NONE;
                                        // lowsrc property not supported
    fill_in->height = hid.HID_size.XYS_height;
    fill_in->width = hid.HID_size.XYS_width;
    fill_in->hspace = hid.hspace;
    fill_in->vspace = hid.vspace;
    fill_in->complete = hid.flags & HTML_IDF_RESOLVED;
    /* use resolved URL, if any */
    if (hid.HID_resolvedURL != NAME_POOL_NONE) {
	fill_in->src = hid.HID_resolvedURL;  /* already in namePool */
	NamePoolUseToken(namePool, hid.HID_resolvedURL);
    } else {
	fill_in->src = NamePoolTokenizeFromPool(namePool, pool, hid.imageURL, FALSE);
    }
    fill_in->name = NamePoolTokenizeFromPool(namePool, pool, hid.name, FALSE);
    }
}


/* Update using the Image structure with the information about the given image
 * magic cookie.
 */
void browserSetImage(jseContext jsecontext,
                     struct BrowserImage *image,
                     struct BrowserImageContents *update_to_match)
{
    optr text;
    word isize;
    struct BrowserImageContents *curImageP;
    NameToken curImageSRC;

    if (OptrToHandle((optr)image) == OptrToHandle(imageHeap)) {
	/* store for dynamically created image */
	MemLock(OptrToHandle((optr)image));
	curImageP = ChunkArrayElementToPtr(imageHeap,
					   (word)(OptrToChunk((optr)image)),
					   &isize);
	curImageSRC = curImageP->src;
	memcpy(curImageP,
	       update_to_match, sizeof(struct BrowserImageContents));
	MemUnlock(OptrToHandle((optr)image));
	/* we are now storing these tokens */
	if (update_to_match->src != NAME_POOL_NONE)
	    NamePoolUseToken(namePool, update_to_match->src);
	if (update_to_match->lowsrc != NAME_POOL_NONE)
	    NamePoolUseToken(namePool, update_to_match->lowsrc);
	if (update_to_match->name != NAME_POOL_NONE)
	    NamePoolUseToken(namePool, update_to_match->name);
	/* pre-load image if new */
	if ((update_to_match->src != curImageSRC) &&
	    /* only if auto-graphic loading is on, otherwise, do it after
	       turned on and triggered by mouseover */
	    (@call NavigateLoadGraphics::MSG_GEN_BOOLEAN_GROUP_GET_SELECTED_BOOLEANS())) {
	    /* released by PRELOAD_GRAPHIC (indirectly) */
	    NamePoolUseToken(namePool, update_to_match->src);
	    if (browserFrameObj) {
		text = @call browserFrameObj::MSG_URL_FRAME_FIND_TEXT_OBJECT();
		if (text) {
		    @send,forceQueue text::MSG_URL_TEXT_PRELOAD_GRAPHIC(
			update_to_match->src);
		}
	    }
	}
    } else {
    text = ConstructOptr(OptrToHandle((optr)image), OptrToChunk(@URLText));

    /* Currently, we only support setting the src property */
    if(update_to_match->src!=NAME_POOL_NONE &&
       /* change only if graphics on, even if already preloaded */
	(@call NavigateLoadGraphics::MSG_GEN_BOOLEAN_GROUP_GET_SELECTED_BOOLEANS()))
    {
      /* Token will be released by MSG_URL_TEXT_UPDATE_GRAPHIC */
      NamePoolUseToken(namePool, update_to_match->src);
      /* _not_ insertAtFront to preserve order for mouseout followed by
	 mouseover affecting the same image */
      @send,forceQueue text::MSG_URL_TEXT_CHANGE_GRAPHIC(
        OptrToChunk((optr)image), update_to_match->src);
    }
    }
}


/* Sets one of the document color properties. See a Javascript book for
 * documentation on the format of the 'color_value' string - you can
 * actually implement it any way you like, as this value is just passed along.
 */
void browserSetDocumentColor(jseContext jsecontext,
                             struct BrowserDocument *document,
                             enum DocumentColors color,
                             const jsecharptr color_value)
{
    ColorQuad quad ;
    optr text ;
    optr parent ;
    VisTextWashColorModeRed wcModeRed ;
    VisTextWashColorBlueGreen wcBlueGreen ;

    text = @call (optr)document::MSG_URL_FRAME_FIND_TEXT_OBJECT();
    if (text && HTMLTranslateColor(color_value, &quad))  {
        wcModeRed.VTWCMR_redOrIndex = quad.CQ_redOrIndex ;
        wcModeRed.VTWCMR_mapMode = quad.CQ_info ;
        wcBlueGreen.VTWCBG_green = quad.CQ_green ;
        wcBlueGreen.VTWCBG_blue = quad.CQ_blue ;
        switch (color) {
            case BgColor:
                parent = @call text::MSG_VIS_FIND_PARENT() ;
                @call parent::MSG_VIS_INVALIDATE() ;
                @call text::MSG_VIS_TEXT_SET_WASH_COLOR(wcModeRed, wcBlueGreen) ;
                break ;
        }
    }
}


/* Gets one of the document color properties */
NameToken browserGetDocumentColor(jseContext jsecontext,
                                  struct BrowserDocument *document,
                                  enum DocumentColors color)
{
    NameToken colorToken = NAME_POOL_NONE ;
    optr text ;
    VisTextGetWashColor washColor ;
    RGBColorAsDWord colorRGB ;
    RGBValue rgb ;
    GStateHandle gstate ;
    TCHAR colorString[10] ;

    text = @call (optr)document::MSG_URL_FRAME_FIND_TEXT_OBJECT();
    if (text)  {
        switch (color)  {
            case BgColor:
                @call text::MSG_VIS_TEXT_GET_WASH_COLOR(&washColor) ;
                if (washColor.VTGWC_modeRed.VTWCMR_mapMode == CF_INDEX)  {
                    gstate = GrCreateState(0) ;
                    colorRGB =
                        GrMapColorIndex(gstate, washColor.VTGWC_modeRed.VTWCMR_redOrIndex);
                    GrDestroyState(gstate) ;
                    rgb.RGB_red = RGB_RED(colorRGB) ;
                    rgb.RGB_green = RGB_GREEN(colorRGB) ;
                    rgb.RGB_blue = RGB_BLUE(colorRGB) ;
                } else {
                    rgb.RGB_red = washColor.VTGWC_modeRed.VTWCMR_redOrIndex ;
                    rgb.RGB_green = washColor.VTGWC_blueGreen.VTWCBG_green ;
                    rgb.RGB_blue = washColor.VTGWC_blueGreen.VTWCBG_blue ;
                }
                /* Finally have an RGB value setup */
                sprintf(colorString, "\#%02X%02X%02X", rgb.RGB_red, rgb.RGB_green, rgb.RGB_blue) ;
                colorToken = NamePoolTokenize(namePool, colorString, TRUE) ;
                break ;
            default:
                LogUnsupported("get document.(colors) -- except BgColor", GETDOCUMENTCOLOR);
                break ;
        }
    }
    return colorToken ;
}


/* Opens the document so to write new contents to it, erasing any old
 * contents.
 */
void browserOpenDocument(jseContext jsecontext,
                         struct BrowserDocument *document,
                         const jsecharptr mimetype)
{
   /* all we do for now is clear out any pending output */
   @call (optr)document::MSG_URL_FRAME_CLEAR_SCRIPT_SRC();
   LogUnsupported("document.open", DOCUMENTOPEN);
}


/* Writes some text to the document. If the document is not open,
 * implictly do an open for "text/html".
 */
void browserDocumentWrite(jseContext jsecontext,
                          struct BrowserDocument *document,
                          const jsecharptr text)
{
    @call (optr)document::MSG_URL_FRAME_ADD_SCRIPT_SRC(text);
}


/* An open document is an output stream for text. When it is closed,
 * all the text has been output and it can be displayed.
 */
void browserCloseDocument(jseContext jsecontext,
                          struct BrowserDocument *document)
{
    /* via queue to make sure we finish with the current sript processing */
    @send, forceQueue (optr)document::MSG_URL_FRAME_FLUSH_SCRIPT_SRC();
}


static NameToken ITokenizeCookieList(optr cookieList)
{
    word remaining = 0 ;
    word numCookieParts ;
    word elSize ;
    optr cookieItem ;
    char *p_item ;
    word i, len ;
    char *cookieBuf = NULL ;
    MemHandle cookieMem = NullHandle ;
    NameToken cookie = NAME_POOL_NONE ;

    if (cookieList)  {
	MemLock(OptrToHandle(cookieList)) ;
	numCookieParts = ChunkArrayGetCount(cookieList) ;
	if (numCookieParts)  {
	    cookieMem = MemAlloc(4096, HF_DYNAMIC, HAF_STANDARD_NO_ERR_LOCK) ;
	    if (cookieMem)  {
		cookieBuf = MemDeref(cookieMem) ;
		remaining = 4095 ;
		for (i=0; i<numCookieParts; i++)  {
		    if (i)  {
			/* Seperate entries with a semicolon and space */
			if (remaining > 1)  {
			    STRCPYSB(cookieBuf, ";") ;
			    cookieBuf++ ;
			    remaining-- ;
			} else {
			    break ;
			}
		    }
		    cookieItem = *((optr *)ChunkArrayElementToPtr(cookieList, i, &elSize)) ;
		    HugeLMemLock(OptrToHandle(cookieItem)) ;
		    p_item = LMemDeref(cookieItem) ;
		    len = STRLENSB(p_item) ;
		    if (len <= remaining)  {
			STRCPYSB(cookieBuf, p_item) ;
			cookieBuf+=len ;
			remaining-=len ;
			len = 0 ;
		    }
		    HugeLMemUnlock(OptrToHandle(cookieItem)) ;
		    HugeLMemFree(cookieItem) ;
		}
		cookieBuf[0] = '\0' ;
		cookieBuf = MemDeref(cookieMem) ;

		/* Convert this monster string into a single token */
		cookie = NamePoolTokenizeDOS(namePool, cookieBuf, TRUE);
		MemFree(cookieMem) ;
	    }
	}
	MemFree(OptrToHandle(cookieList)) ;
    }

    return cookie ;
}

typedef struct {
    MemHandle memSelf ;
    TCHAR anchorHost[URL_MAX_SERVER] ;
    TCHAR anchorPath[HTML_MAX_BUF] ;
    TCHAR type[URL_MAX_TYPE] ;
    TCHAR *p_url ;
} T_parsedURL ;

/* Returns the mem handle to a locked block */
T_parsedURL *IParseURLToken(NameToken url)
{
    MemHandle mem ;
    T_parsedURL *p_data = NULL ;

    if (url != NAME_POOL_NONE)  {
        mem = MemAlloc(sizeof(T_parsedURL), HF_DYNAMIC, HAF_STANDARD_NO_ERR_LOCK) ;
        if (mem)  {
            p_data = MemDeref(mem) ;
            p_data->memSelf = mem ;
            NamePoolCopy(namePool, NULL, 0, url, &p_data->p_url) ;
            ToolsParseURL(p_data->p_url, p_data->type, p_data->anchorHost, p_data->anchorPath) ;
        }
    }

    return p_data ;
}

/* Gets the values of the cookies for this document in the form
 * "name=value;name=value;..."
 */
NameToken browserGetCookie(jseContext jsecontext,
                           struct BrowserDocument *document)
{
    NameToken url ;
    NameToken cookie = NAME_POOL_NONE ;
    Boolean isSecure = FALSE ;
    T_parsedURL *p_data ;

    /* Get the frame's complete url */
    url = @call ((optr)document)::MSG_URL_FRAME_GET_URL() ;
    p_data = IParseURLToken(url) ;

    if (p_data)  {
	/* Is this an HTTPS site? */
	if (strcmpi(p_data->type, _TEXT("HTTPS")))
	    isSecure = TRUE ;

	/* Find and convert into a tokenized name */
	cookie = ITokenizeCookieList(CookieFind(p_data->anchorPath, p_data->anchorHost, isSecure)) ;

	/* Done with url */
	NamePoolDestroyIfDynamic(p_data->p_url) ;
        MemFree(p_data->memSelf) ;
    }

    return cookie ;
}


/* Sets the cookie value by adding a single "name=value" item which must
 * be integrated into the cookie list. It can have an 'expires' clause,
 * 'path' clause, 'domain' clause, and 'secure' clause.
 */
void browserSetCookie(jseContext jsecontext,
                           struct BrowserDocument *document,
                           const jsecharptr cookie)
{
    NameToken url ;
    T_parsedURL *p_data ;

    /* Get the frame's complete url */
    url = @call ((optr)document)::MSG_URL_FRAME_GET_URL() ;
    p_data = IParseURLToken(url) ;

    if (p_data)  {
	/* Set the cookie after parsing out all the other traits */
        CookieParse(p_data->anchorPath, p_data->anchorHost, cookie) ;

	/* Done with url */
	NamePoolDestroyIfDynamic(p_data->p_url) ;
        MemFree(p_data->memSelf) ;
    }
}


/* Returns a text string which is the date of the last modified field
 * or Jan 1st, 1970 (midnight) if none. The date should be in the format:
 *
 * 'Wed Dec 3 12:46:52 1997'
 */
NameToken browserGetLastModified(jseContext jsecontext,
                                 struct BrowserDocument *document)
{
   /*** must implement ***/
   LogUnsupported("get document.lastModified", GETLASTMODIFIED);
   return NAME_POOL_NONE;
}


/* Return the location magic cookie for this document */
struct BrowserLocation *browserGetDocumentLocation(jseContext jsecontext,
                                                   struct BrowserDocument *document)
{
   /* Current implementation allows only windows to have a location */
   return (struct BrowserLocation *)document;
}


/* Get a string representing the complete URL of the referring document,
 * or the empty string if none.
 */
NameToken browserGetReferrer(jseContext jsecontext,
                             struct BrowserDocument *document)
{
    return @call (optr)document::MSG_URL_FRAME_GET_REFERRER();
}


/* Get a string representing the title of the document. */
NameToken browserGetTitle(jseContext jsecontext,
                          struct BrowserDocument *document)
{
    return @call (optr)document::MSG_URL_FRAME_GET_TITLE();
}


/* Fill in the Form structure with the values from this form. */
void browserGetForm(jseContext jsecontext,
                    struct BrowserForm *form,
                    struct BrowserFormContents *fill_in)
{
    optr text;
    optr pool;
    HTMLformData hfd;

    text = ConstructOptr(OptrToHandle((optr)form), OptrToChunk(@URLText));
    pool = @call text::MSG_HTML_TEXT_GET_NAME_POOL();

    /* Get requested form element from text object */
    @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(OptrToChunk((optr)form), &hfd);

    fill_in->action = NamePoolTokenizeFromPool(namePool, pool,
      hfd.HFD_name, FALSE);
    fill_in->name = NamePoolTokenizeFromPool(namePool, pool,
      hfd.HFD_prompt, FALSE);
    fill_in->target = NamePoolTokenizeFromPool(namePool, pool,
      hfd.HFD_value, FALSE);
    fill_in->encoding = NamePoolTokenizeDOS(namePool,
      ((hfd.HFD_var.header.options & HTML_OPT_ENCODING_MASK)==HTML_OPT_ENCODING_MULTI)?
        "multipart/form-data":"application/x-www-form-urlencoded",
      FALSE);
    fill_in->method = NamePoolTokenizeDOS(namePool,
      ((hfd.HFD_var.header.options & HTML_OPT_METHOD_MASK)==HTML_OPT_METHOD_POST)?
        "post":"get",
      FALSE);
}


/* Update the form with any changes in the Form structure. */
void browserSetForm(jseContext jsecontext,
                    struct BrowserForm *form,
                    struct BrowserFormContents *read_changes_from)
{
    optr text;
    optr pool;
    HTMLformData hfd;
    TCHAR methodStr[10];

    text = ConstructOptr(OptrToHandle((optr)form), OptrToChunk(@URLText));
    pool = @call text::MSG_HTML_TEXT_GET_NAME_POOL();

    /* Get requested form element from text object */
    @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(OptrToChunk((optr)form), &hfd);

    /* only handle setting form.action */
    if (hfd.HFD_itemType == HTML_FORM_HEADER) {
	hfd.HFD_name = NamePoolTokenizeFromPool(pool, namePool,
						read_changes_from->action, FALSE);
	NamePoolCopy(namePool, methodStr, sizeof(methodStr),
		     read_changes_from->method, 0);
	    hfd.HFD_var.header.options &= ~HTML_OPT_METHOD_MASK;
	if (LocalCmpStringsNoCase(methodStr, _TEXT("post"), 0)==0) {
	    hfd.HFD_var.header.options |= HTML_OPT_METHOD_POST;
	} else {
	    hfd.HFD_var.header.options |= HTML_OPT_METHOD_GET;
	}
	/* this doesn't generate any JavaScript events, so we can @call it */
	@call text::MSG_HTML_TEXT_SET_FORM_ELEMENT(OptrToChunk((optr)form), &hfd);
    } else {
	LogUnsupported("set form.(properties) except .action/.method", SETFORM);
    }
}


/* Reset all the fields of the form. */
void browserFormReset(jseContext jsecontext,
                      struct BrowserForm *form)
{
    HTMLformData hfd;
    optr text = ConstructOptr(OptrToHandle((optr)form), OptrToChunk(@URLText));

    @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(OptrToChunk((optr)form), &hfd);
    @send,forceQueue,insertAtFront text::
      MSG_HTML_TEXT_FORM_RESET(hfd.HFD_formNumber);
}


/* Submit the form. */
void browserFormSubmit(jseContext jsecontext,
                       struct BrowserForm *form)
{
    HTMLformData hfd;
    optr text = ConstructOptr(OptrToHandle((optr)form), OptrToChunk(@URLText));

    @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(OptrToChunk((optr)form), &hfd);
    @send,forceQueue,insertAtFront text::
      MSG_HTML_TEXT_FORM_SUBMIT(hfd.HFD_formNumber, FALSE);
}


/* Fills in an Element structure based on the element. */
void browserGetElement(jseContext jsecontext,
                       struct BrowserElement *elem,
                       struct BrowserElementContents *fill_in)
{
    optr text, pool;
    HTMLformData el,opt;
    char *type;
    TCHAR *p;
    MemHandle mem;
    word i,n,index;

    text = ConstructOptr(OptrToHandle((optr)elem), OptrToChunk(@URLText));
    pool = @call text::MSG_HTML_TEXT_GET_NAME_POOL();

    /* get form header (for retrieving its number that keeps it all together) */
    index = OptrToChunk((optr)elem);
    @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(index, &el);

    memset(fill_in, 0, sizeof(*fill_in));
    switch(el.HFD_itemType)
    {
      case HTML_FORM_SELECT:
        fill_in->selectedIndex = (ulong)-1;
                                        // no selected element found yet
        n = @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT_COUNT();
        for(i = index+1; i<n; i++)
        {
          @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(i, &opt);
          if(opt.HFD_itemType==HTML_FORM_OPTION &&
	     !(opt.HFD_var.option.flags & HTML_OPTION_DELETED) &&
             opt.HFD_var.option.menuElement == index)
          {
            if((opt.HFD_runtimeState & HTML_OPTION_SELECTED) &&
               fill_in->selectedIndex == (ulong)-1)
              fill_in->selectedIndex = fill_in->num_options;
            fill_in->num_options++;
          }
        }
        fill_in->si_used = TRUE;
        fill_in->options_used = TRUE;

        type = (el.HFD_var.select.flags & HTML_SELECT_MULTI)?
          "select-multiple" : "select-one";
        break;

      case HTML_FORM_TEXT:
      case HTML_FORM_PASSWORD:
        fill_in->value = NamePoolTokenizeFromPool(namePool, pool,
          (NameToken)el.HFD_runtimeState, FALSE);
        fill_in->value_used = TRUE;

        fill_in->defaultValue = NamePoolTokenizeFromPool(namePool, pool,
          el.HFD_value, FALSE);
        fill_in->dv_used = TRUE;

        type = (el.HFD_itemType==HTML_FORM_TEXT)? "text":"password";
        break;

      case HTML_FORM_TEXTAREA:
	mem = (MemHandle)el.HFD_runtimeState;
        if(mem)                         // Tokenize current value, if any
        {
          p = MemLock(mem);
          fill_in->value = NamePoolTokenize(namePool, p, FALSE);
          MemUnlock(mem);
        }
        fill_in->value_used = TRUE;

        fill_in->defaultValue = NamePoolTokenizeFromPool(namePool, pool,
          el.HFD_value, FALSE);
        fill_in->dv_used = TRUE;

        type = "textarea";
        break;

      case HTML_FORM_RADIO:
      case HTML_FORM_CHECKBOX:
        fill_in->checked = el.HFD_runtimeState? TRUE:FALSE;
        fill_in->checked_used = TRUE;

        fill_in->defaultChecked =
          el.HFD_var.checkbox_radio.flags & HTML_BOOLEAN_SELECTED;
        fill_in->dc_used = TRUE;

        type = (el.HFD_itemType==HTML_FORM_RADIO)? "radio":"checkbox";

	if (el.HFD_value)
	    fill_in->value = NamePoolTokenizeFromPool(namePool, pool,
						      el.HFD_value, FALSE);
	fill_in->value_used = TRUE;
        break;

      case HTML_FORM_SUBMIT:
      case HTML_FORM_RESET:
        if(el.HFD_value)                // explicitly specified moniker?
          fill_in->value = NamePoolTokenizeFromPool(namePool, pool,
            el.HFD_value, FALSE);
        else                            // no: use a default text
          fill_in->value = NamePoolTokenize(namePool,
            (el.HFD_itemType==HTML_FORM_SUBMIT)? "Submit":"Reset",
            FALSE);
        fill_in->value_used = TRUE;

        type = (el.HFD_itemType==HTML_FORM_SUBMIT)? "submit":"reset";
        break;

      case HTML_FORM_BUTTON:
	  /* return button value -- brianc 8/15/00 */
        if(el.HFD_value) {
          fill_in->value = NamePoolTokenizeFromPool(namePool, pool,
            el.HFD_value, FALSE);
	  fill_in->value_used = TRUE;
	}
        type = "button";
        break;

      case HTML_FORM_IMAGE:
        /* can we return any other fields for an image? */
        type = "image";
        break;

      case HTML_FORM_HIDDEN:
      case HTML_FORM_FILE:
        fill_in->value = NamePoolTokenizeFromPool(namePool, pool,
          (NameToken)el.HFD_runtimeState, FALSE);
        fill_in->value_used = TRUE;

        type = (el.HFD_itemType==HTML_FORM_HIDDEN)? "hidden":"file";
        break;
    }

    /* these fields are always present */
    fill_in->type = NamePoolTokenizeDOS(namePool, type, FALSE);
    fill_in->name = NamePoolTokenizeFromPool(namePool, pool, el.HFD_name, FALSE);
}

/* Gets the next element with the same name, if any */
struct BrowserElement *browserNextArrayElement(jseContext jsecontext,
                                               struct BrowserElement *elem)
{
    optr text;
    HTMLformData el,el2;
    word i,n,sel;

    text = ConstructOptr(OptrToHandle((optr)elem), OptrToChunk(@URLText));

    /* get name we want to find the successor for */
    sel = OptrToChunk((optr)elem);
    @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(sel, &el);

    n = @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT_COUNT();
    for(i = sel+1; i<n; i++)
    {
      @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(i, &el2);
      /* abort if arrived at next form - no more elements in this one */
      if(el2.HFD_formNumber != el.HFD_formNumber)
        break;
      /* found if element's name is the same as ours */
      if(el2.HFD_name == el.HFD_name)
        return (struct BrowserElement *)(ConstructOptr(OptrToHandle(text), i));
    }

    return NULL;
}

/* Updates the element -- brianc 8/15/00 */
void browserSetElement(jseContext jsecontext,
                       struct BrowserElement *elem,
                       struct BrowserElementContents *fill_in)

{
    optr text, pool;
    HTMLformData el,opt;
    char *p;
    MemHandle mem;
    word i,n,index;
    int sel, len;

    text = ConstructOptr(OptrToHandle((optr)elem), OptrToChunk(@URLText));
    pool = @call text::MSG_HTML_TEXT_GET_NAME_POOL();

    /* get form header */
    index = OptrToChunk((optr)elem);
    @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(index, &el);

    switch(el.HFD_itemType)
    {
      case HTML_FORM_SELECT:
	  /* exclusivity is enforced in MSG_HTML_TEXT_SET_FORM_ELEMENT */
        sel = fill_in->selectedIndex;
                                        // find specified selection
        n = @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT_COUNT();
        for(i = index+1; i<n; i++)
        {
          @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(i, &opt);
          if(opt.HFD_itemType==HTML_FORM_OPTION &&
	     !(opt.HFD_var.option.flags & HTML_OPTION_DELETED) &&
             opt.HFD_var.option.menuElement == index)
          {
	      if(sel) {
		  sel--;
	      } else {
		  opt.HFD_runtimeState |= HTML_OPTION_SELECTED;
		  /* update OPTION, not SELECT */
		  index = i;
		  memcpy(&el, &opt, sizeof(el));
		  break;
	      }
          }
        }
	/* else, no change */
        break;

      case HTML_FORM_TEXT:
      case HTML_FORM_PASSWORD:
	el.HFD_value = NamePoolTokenizeFromPool(pool, namePool,
						fill_in->defaultValue, FALSE);
	/* FALL THROUGH */
      case HTML_FORM_HIDDEN:
	el.HFD_runtimeState = NamePoolTokenizeFromPool(pool, namePool,
						       fill_in->value, FALSE);
        break;

      case HTML_FORM_TEXTAREA:
	/* runtime state uses mem block */
	len = (NamePoolStrLength(namePool, fill_in->value)+1)*sizeof(TCHAR);
	mem = MemAlloc(len, HF_DYNAMIC, HAF_STANDARD_LOCK);
	if (mem) {
	    p = MemDeref(mem);
	    NamePoolCopy(namePool, p, len, fill_in->value, NULL);
	    MemUnlock(mem);
	}
	el.HFD_runtimeState = mem;
	/* default value uses NameToken */
	el.HFD_value = NamePoolTokenizeFromPool(pool, namePool,
						fill_in->defaultValue, FALSE);
        break;

      case HTML_FORM_RADIO:
      case HTML_FORM_CHECKBOX:
	el.HFD_runtimeState = fill_in->checked ? TRUE:FALSE;
	/* Checkbox.defaultChecked is read-only, no need to look at
	   fill_in->defaultChecked */
        break;

      case HTML_FORM_SUBMIT:
      case HTML_FORM_RESET:
	  /* TBD: value (button name) change not supported */
        break;

      case HTML_FORM_IMAGE:
	  /* TBD: value (picture?) change not supported */
        break;

      case HTML_FORM_FILE:
	  /* TBD: value (selected file) change not supported */
        break;
    }

    /* this doesn't generate any JavaScript events, so we can @call it */
    @call text::MSG_HTML_TEXT_SET_FORM_ELEMENT(index, &el);

    /* tokens in el released by caller */
}


/* Standard element actions */
void browserElementBlur(jseContext jsecontext,
                        struct BrowserElement *elem)
{
    optr text = ConstructOptr(OptrToHandle((optr)elem), OptrToChunk(@URLText));
    @send,forceQueue,insertAtFront
      text::MSG_HTML_TEXT_FORM_ELEMENT_RELEASE();
}

@extern object HTMLDisplayGroup;
void browserElementClick(jseContext jsecontext,
                         struct BrowserElement *elem)
{
    Point rel = {0, 0};

    optr text = ConstructOptr(OptrToHandle((optr)elem), OptrToChunk(@URLText));
    @send, forceQueue HTMLDisplayGroup::MSG_META_GRAB_FOCUS_EXCL();
    /* focus change will be queued at end to try to let page building
       finish as much as possible */
    @send,forceQueue text::
      MSG_HTML_TEXT_FORM_ELEMENT_START_AFTER_GRAB(OptrToChunk((optr)elem), rel);
    /* XXX: although spec says otherwise, activate 'onClick' event since IE and
       Netscape do */
    @send,forceQueue text::
	MSG_HTML_TEXT_FIRE_EVENT(HTML_EVENT_CLICK,
				 HTML_EVENT_OBJECT_ELEMENT,
				 OptrToChunk((optr)elem));
}

void browserElementFocus(jseContext jsecontext,
                         struct BrowserElement *elem)
{
    optr text = ConstructOptr(OptrToHandle((optr)elem), OptrToChunk(@URLText));
    @send, forceQueue HTMLDisplayGroup::MSG_META_GRAB_FOCUS_EXCL();
    /* focus change will be queued at end to try to let page building
       finish as much as possible */
    @send,forceQueue text::
	MSG_HTML_TEXT_FOCUS_FORM_ELEMENT(OptrToChunk((optr)elem));
}

void browserElementSelect(jseContext jsecontext,
                          struct BrowserElement *elem)
{
   /*** must implement ***/
   LogUnsupported("element.select", ELEMENTSELECT);
}


/* Read the state of an option of an element (only applies to
 * select elements.)
 */
void browserGetElementOption(jseContext jsecontext,
                             struct BrowserElement *elem,
                             ulong index,
                             struct BrowserOptionContents *fill_in,
			     Boolean removeFromHeap)
{
    optr text, pool;
    HTMLformData el,opt;
    struct BrowserOptionContents *heapItem;
    word i,n,sel;
    word esize;

    if (OptrToHandle((optr)elem) == OptrToHandle(optionHeap)) {
	/* fetch for dynamically created option */
	MemLock(OptrToHandle((optr)elem));
	heapItem = ChunkArrayElementToPtr(optionHeap,
					  (word)(OptrToChunk((optr)elem)),
					  &esize);
	memcpy(fill_in, heapItem, sizeof(struct BrowserOptionContents));
	/* remove from option heap, if requested */
	if (removeFromHeap) {
	    /* note that position indexes are important, so we cannot
	       actually delete the item */
	    heapItem->index = 0xffff;
	}
	MemUnlock(OptrToHandle((optr)elem));
	/* add reference for caller */
	if (fill_in->text != NAME_POOL_NONE)
	    NamePoolUseToken(namePool, fill_in->text);
	if (fill_in->value != NAME_POOL_NONE)
	    NamePoolUseToken(namePool, fill_in->value);
    } else {
    text = ConstructOptr(OptrToHandle((optr)elem), OptrToChunk(@URLText));
    pool = @call text::MSG_HTML_TEXT_GET_NAME_POOL();

    /* get form header (for retrieving its number that keeps it all together) */
    sel = OptrToChunk((optr)elem);
    @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(sel, &el);

    memset(fill_in, 0, sizeof(*fill_in));
    fill_in->index = (uint)index;

    n = @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT_COUNT();
    for(i = sel+1; i<n; i++)
    {
      @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(i, &opt);
      if(opt.HFD_itemType==HTML_FORM_OPTION &&
	 !(opt.HFD_var.option.flags & HTML_OPTION_DELETED) &&
         opt.HFD_var.option.menuElement == sel)
      {
        if(index--==0)                  // hit requested item?
        {
          fill_in->text = NamePoolTokenizeFromPool(namePool, pool,
            opt.HFD_value, FALSE);      // text of option
          fill_in->value = NamePoolTokenizeFromPool(namePool, pool,
            opt.HFD_name, FALSE);       // value attribute of option

          fill_in->defaultSelected =
            (opt.HFD_var.option.flags & HTML_OPTION_SELECTED)? TRUE:FALSE;
          fill_in->selected = (opt.HFD_runtimeState & HTML_OPTION_SELECTED)?
            TRUE:FALSE;
          break;                        // got it...
        }
      }
    }
    }
}

/* Set the state of an option of an element.
 */
void browserSetElementOption(jseContext jsecontext,
                             struct BrowserElement *elem,
                             struct BrowserOptionContents *fill_in)
{
    word esize;
    struct BrowserOptionContents *curOptP;

    if (OptrToHandle((optr)elem) == OptrToHandle(optionHeap)) {
	/* store for dynamically created option */
	MemLock(OptrToHandle((optr)elem));
	curOptP = ChunkArrayElementToPtr(optionHeap,
					 (word)(OptrToChunk((optr)elem)),
					 &esize);
	memcpy(curOptP,
	       fill_in, sizeof(struct BrowserOptionContents));
	MemUnlock(OptrToHandle((optr)elem));
	/* we are now storing these tokens */
	if (fill_in->text != NAME_POOL_NONE)
	    NamePoolUseToken(namePool, fill_in->text);
	if (fill_in->value != NAME_POOL_NONE)
	    NamePoolUseToken(namePool, fill_in->value);
    }
    /* text and value are read-only, nothing to do here */
}

/* Add (or update) new option to select list */
struct BrowserElement *browserAssignElementOption(jseContext jsecontext,
						  struct BrowserElement *parent,
						  struct BrowserOptionContents *opt)
{
    optr text = ConstructOptr(OptrToHandle((optr)parent), OptrToChunk(@URLText));
    optr pool = @call text::MSG_HTML_TEXT_GET_NAME_POOL();
    HTMLformData head, el;
    word index;

    /* spec extension: handle updating existing option */
    if (opt->index < browserGetOptionsLength(jsecontext, parent)) {
	/* delete current one, then fall through to add new */
	browserRemoveElementOption(jsecontext, parent, opt->index);
    }
    /* add new option */
    @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(OptrToChunk((optr)parent), &head);
    el.HFD_pos = head.HFD_pos;
    el.HFD_itemType = HTML_FORM_OPTION;
    el.HFD_formNumber = head.HFD_formNumber;
    el.HFD_name = NamePoolTokenizeFromPool(pool, namePool, opt->value, FALSE);
    el.HFD_value = NamePoolTokenizeFromPool(pool, namePool, opt->text, FALSE);
    el.HFD_prompt = NAME_POOL_NONE;
    el.HFD_runtimeState = (opt->selected) ? HTML_OPTION_SELECTED : 0;
    el.HFD_var.option.menuElement = OptrToChunk((optr)parent);
    el.HFD_var.option.flags = (opt->defaultSelected) ? HTML_OPTION_SELECTED : 0;
    el.x = -1;
    el.y = -1;
    index = @call text::MSG_HTML_TEXT_ADD_OPTION_ELEMENT(&el);
    return (struct BrowserElement *)(ConstructOptr(OptrToHandle((optr)parent), index));
}

/* Remove option from select list */
void browserRemoveElementOption(jseContext jsecontext,
				struct BrowserElement *parent,
				word index)
{
    optr text = ConstructOptr(OptrToHandle((optr)parent), OptrToChunk(@URLText));
    word selIdx = OptrToChunk(parent), i, count;
    HTMLformData opt, sel;

    @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(selIdx, &sel);
    count = @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT_COUNT();
    for (i = 0; i < count; i++) {
	@call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(i, &opt);
	if (opt.HFD_itemType == HTML_FORM_OPTION &&
	    !(opt.HFD_var.option.flags & HTML_OPTION_DELETED) &&
	    opt.HFD_formNumber == sel.HFD_formNumber &&
	    opt.HFD_var.option.menuElement == selIdx) {
	    if (index == 0) {
		/* found it */
		@call text::MSG_HTML_TEXT_REMOVE_OPTION_ELEMENT(i);
		break;
	    } else {
		index--;
	    }
	}
    }
}

/* Register some code to be called within the context of the given
 * window in a given number of milliseconds. The return is a magic handle
 * that can be used to cancel the timeout code. The code is to be executed
 * once when the timeout goes off.
 */
struct BrowserTimeout *browserSetTimeout(jseContext jsecontext,
                                         struct BrowserWindow *current_window,
                                         const jsecharptr js_code,
                                         ulong timeout_in_millisecs)
{
    /* Just pass it on */
    return (struct BrowserTimeout *)
        (@call (optr)current_window::MSG_URL_FRAME_START_TIMER(
                    timeout_in_millisecs,
                    NamePoolTokenizeDOS(namePool, js_code, TRUE),
					FALSE)) ;
}


/* Clear a previously-set timeout if possible. */
void browserClearTimeout(jseContext jsecontext,
                         struct BrowserWindow *current_window,
                         struct BrowserTimeout *tm)
{
    /* Pass it on to the frame to kill */
    @call (optr)current_window::MSG_URL_FRAME_STOP_TIMER(
            (word)(dword)tm,
			FALSE) ;
}

struct BrowserTimeout *browserSetInterval(jseContext jsecontext,
                                         struct BrowserWindow *current_window,
                                         const jsecharptr js_code,
                                         ulong timeout_in_millisecs)
{
    /* Just pass it on */
    return (struct BrowserTimeout *)
        (@call (optr)current_window::MSG_URL_FRAME_START_TIMER(
                    timeout_in_millisecs,
                    NamePoolTokenizeDOS(namePool, js_code, TRUE),
					TRUE)) ;
}


/* Clear a previously-set timeout if possible. */
void browserClearInterval(jseContext jsecontext,
                         struct BrowserWindow *current_window,
                         struct BrowserTimeout *tm)
{
    /* Pass it on to the frame to kill */
    @call (optr)current_window::MSG_URL_FRAME_STOP_TIMER(
            (word)(dword)tm,
			FALSE) ;
}


/* Get number of frames.
 */
ulong browserGetFramesLength(jseContext jsecontext,
			     struct BrowserWindow *frameArray)
{
    MemHandle listBlock;
    optr list;
    ulong total = 0;

    listBlock = MemAllocLMem(LMEM_TYPE_GENERAL, 0);
    if (listBlock) {
	MemLock(listBlock);
	list = ConstructOptr(listBlock, ChunkArrayCreate(listBlock, sizeof(optr), 0, 0));
	browserGetFrameList(jsecontext, frameArray, &list);
	total = ChunkArrayGetCount(list);
	MemFree(listBlock);
    }
    return total;
}


/* Get magic cookie for frame array item.
 */
struct BrowserWindow *browserGetFrameItem(jseContext jsecontext,
					  struct BrowserWindow *frameArray,
					  ulong index)
{
    MemHandle listBlock;
    optr list;
    optr item = NullOptr, *itemP;
    word size;

    listBlock = MemAllocLMem(LMEM_TYPE_GENERAL, 0);
    if (listBlock) {
	MemLock(listBlock);
	list = ConstructOptr(listBlock, ChunkArrayCreate(listBlock, sizeof(optr), 0, 0));
	browserGetFrameList(jsecontext, frameArray, &list);
	if (index < ChunkArrayGetCount(list)) {
	    itemP = ChunkArrayElementToPtr(list, index, &size);
	    item = *itemP;
	}
	MemFree(listBlock);
    }
    return (struct BrowserWindow *)item;
}


/* Get magic cookie for frame array item from name.
 */
struct BrowserWindow *browserGetFrameItemFromName(jseContext jsecontext,
						  struct BrowserWindow *frameArray,
						  const jsecharptr name)
{
    MemHandle listBlock;
    optr list;
    optr item = NullOptr, *itemP;
    word i, n;
    word size;
    NameToken nameT = NAME_POOL_NONE;

    listBlock = MemAllocLMem(LMEM_TYPE_GENERAL, 0);
    if (listBlock) {
	nameT = NamePoolTokenizeDOS(namePool, name, TRUE);
	MemLock(listBlock);
	list = ConstructOptr(listBlock, ChunkArrayCreate(listBlock, sizeof(optr), 0, 0));
	browserGetFrameList(jsecontext, frameArray, &list);
	n = ChunkArrayGetCount(list);
	for (i = 0; i < n; i++) {
	    itemP = ChunkArrayElementToPtr(list, i, &size);
	    item = *itemP;
	    if (nameT == browserGetNameOfWindow(jsecontext, (struct BrowserWindow *)item)) {
		/* found it */
		break;
	    }
	}
	MemFree(listBlock);
	NamePoolReleaseToken(namePool, nameT);
    }
    return (struct BrowserWindow *)item;
}


/* Get magic cookie for link array.
 */
struct BrowserLinksArray *browserGetLinksArray(jseContext jsecontext,
					 struct BrowserDocument *doc)
{
    return (struct BrowserLinksArray *)(@call (optr)doc::MSG_URL_FRAME_FIND_TEXT_OBJECT());
}


/* Get magic cookie for link array item.
 */
struct BrowserLocation *browserGetLinkItem(jseContext jsecontext,
					   struct BrowserLinksArray *links,
					   ulong index)
{
    optr text = ConstructOptr(OptrToHandle((optr)links), OptrToChunk(@URLText));
    int i, count;
    HTMLanchorData had;
    struct BrowserLocation *loc;

    /* loop to find link array index of requested link index */
    count = @call text::MSG_HTML_TEXT_GET_LINK_COUNT();
    for (i = 0; i < count; i++) {
	@call text::MSG_HTML_TEXT_GET_LINK(i, &had);
	if ((had.flags & (HTML_ADF_NAME | HTML_ADF_MAP)) == 0) {
	    if (index == 0) {
		/* found it */
		loc = (struct BrowserLocation *)(ConstructOptr(OptrToHandle(text), ((word)i | 0x8000)));
		break;
	    } else {
		index--;
	    }
	}
    }
    return loc;
}


/* Get magic cookie for link array item from name.
 */
struct BrowserLocation *browserGetLinkItemFromName(jseContext jsecontext,
						   struct BrowserLinksArray *links,
						   const jsecharptr name)
{
    optr text = ConstructOptr(OptrToHandle((optr)links), OptrToChunk(@URLText));
    optr pool = links? (@call text::MSG_HTML_TEXT_GET_NAME_POOL()) : 0;
    NameToken nameT;
    struct BrowserLocation *bl = 0;
    word ret;

    if (*name && pool) {
	nameT = NamePoolTokenizeDOS(pool, name, TRUE);
	ret = @call text::MSG_URL_TEXT_FIND_LINK_FROM_NAME(nameT);
	if (ret != 0xffff) {
	    /* found it */
	    bl = (struct BrowserLocation *)(ConstructOptr(OptrToHandle(text), ((word)ret | 0x8000)));
	}
	NamePoolReleaseToken(pool, nameT);
    }
    return bl;
}


/* Get number of links.
 */
ulong browserGetLinksLength(jseContext jsecontext,
			    struct BrowserLinksArray *links)
{
    optr text = ConstructOptr(OptrToHandle((optr)links), OptrToChunk(@URLText));
    int i, count;
    ulong realCount = 0;
    HTMLanchorData had;

    /* loop to find count real links in link array */
    count = @call text::MSG_HTML_TEXT_GET_LINK_COUNT();
    for (i = 0; i < count; i++) {
	@call text::MSG_HTML_TEXT_GET_LINK(i, &had);
	if ((had.flags & (HTML_ADF_NAME | HTML_ADF_MAP)) == 0) realCount++;
    }
    return realCount;
}


/* Get magic cookie for image array.
 */
struct BrowserImagesArray *browserGetImagesArray(jseContext jsecontext,
						 struct BrowserDocument *doc)
{
    return (struct BrowserImagesArray *)(@call (optr)doc::MSG_URL_FRAME_FIND_TEXT_OBJECT());
}


/* Get magic cookie for image array item.
 */
struct BrowserImage *browserGetImageItem(jseContext jsecontext,
					 struct BrowserImagesArray *images,
					 ulong index)
{
    optr text = ConstructOptr(OptrToHandle((optr)images), OptrToChunk(@URLText));
    int i, count;
    HTMLimageData img;
    struct BrowserImage *bi = 0;

    /* loop to find image array index of requested image index */
    count = @call text::MSG_HTML_TEXT_GET_IMAGE_COUNT();
    for (i = 0; i < count; i++) {
	@call text::MSG_HTML_TEXT_GET_IMAGE(i, &img);
	if (img.pos < HTML_IMAGE_POS_RESERVED) {
	    if (index == 0) {
		/* found it */
		bi = (struct BrowserImage *)(ConstructOptr(OptrToHandle(text), (word)i));
		break;
	    } else {
		index--;
	    }
	}
    }
    return bi;
}


/* Get magic cookie for image array item from name.
 */
struct BrowserImage *browserGetImageItemFromName(jseContext jsecontext,
						 struct BrowserImagesArray *images,
						 const jsecharptr name)
{
    optr text = ConstructOptr(OptrToHandle((optr)images), OptrToChunk(@URLText));
    optr pool = images? (@call text::MSG_HTML_TEXT_GET_NAME_POOL()) : 0;
    NameToken nameT;
    struct BrowserImage *bi = 0;
    word ret;

    if (*name && pool) {
	nameT = NamePoolTokenizeDOS(pool, name, TRUE);
	ret = @call text::MSG_URL_TEXT_FIND_IMAGE_FROM_NAME(nameT);
	if (ret != 0xffff) {
	    /* found it */
	    bi = (struct BrowserImage *)(ConstructOptr(OptrToHandle(text), (word)ret));
	}
	NamePoolReleaseToken(pool, nameT);
    }
    return bi;
}


/* Get number of images.
 */
ulong browserGetImagesLength(jseContext jsecontext,
			     struct BrowserImagesArray *images)
{
    optr text = ConstructOptr(OptrToHandle((optr)images), OptrToChunk(@URLText));
    int i, count;
    ulong realCount = 0;
    HTMLimageData img;

    /* loop to count real images in image array */
    count = @call text::MSG_HTML_TEXT_GET_IMAGE_COUNT();
    for (i = 0; i < count; i++) {
	@call text::MSG_HTML_TEXT_GET_IMAGE(i, &img);
	if (img.pos < HTML_IMAGE_POS_RESERVED) realCount++;
    }
    return realCount;
}


/* Get magic cookie for window containing specified image.
 */
struct BrowserWindow *browserGetImageWindow(jseContext jsecontext,
					   struct BrowserImage *bi)
{
    optr text = ConstructOptr(OptrToHandle((optr)bi), OptrToChunk(@URLText));
    optr frame;

    frame = @call text::MSG_URL_TEXT_GET_FRAME_OBJ();
    return (struct BrowserWindow *)(@call frame::MSG_URL_FRAME_FIND_REAL_FRAME());
}


/* Get magic cookie for form array.
 */
struct BrowserFormsArray *browserGetFormsArray(jseContext jsecontext,
					       struct BrowserDocument *doc)
{
    return (struct BrowserFormsArray *)(@call (optr)doc::MSG_URL_FRAME_FIND_TEXT_OBJECT());
}


/* Get magic cookie for form array item.
 */
struct BrowserForm *browserGetFormItem(jseContext jsecontext,
				       struct BrowserFormsArray *forms,
				       ulong index)
{
    optr text = ConstructOptr(OptrToHandle((optr)forms), OptrToChunk(@URLText));
    int i, count;
    HTMLformData frm;
    struct BrowserForm *bf = 0;

    /* loop to find form array index of requested form index */
    count = @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT_COUNT();
    for (i = 0; i < count; i++) {
	@call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(i, &frm);
	if (frm.HFD_itemType == HTML_FORM_HEADER) {
	    if (index == 0) {
		/* found it */
		bf = (struct BrowserForm *)(ConstructOptr(OptrToHandle(text), (word)i));
		break;
	    } else {
		index--;
	    }
	}
    }
    return bf;
}


/* Get magic cookie for form array item from name.
 */
struct BrowserForm *browserGetFormItemFromName(jseContext jsecontext,
					       struct BrowserFormsArray *forms,
					       const jsecharptr name)
{
    optr text = ConstructOptr(OptrToHandle((optr)forms), OptrToChunk(@URLText));
    optr pool = forms? (@call text::MSG_HTML_TEXT_GET_NAME_POOL()) : 0;
    NameToken nameT;
    struct BrowserForm *bf = 0;
    word ret;

    if (*name && pool) {
	nameT = NamePoolTokenizeDOS(pool, name, TRUE);
	ret = @call text::MSG_URL_TEXT_FIND_FORM_FROM_NAME(nameT);
	if (ret != 0xffff) {
	    /* found it */
	    bf = (struct BrowserForm *)(ConstructOptr(OptrToHandle(text), (word)ret));
	}
	NamePoolReleaseToken(pool, nameT);
    }
    return bf;
}


/* Get number of forms.
 */
ulong browserGetFormsLength(jseContext jsecontext,
			    struct BrowserFormsArray *forms)
{
    optr text = ConstructOptr(OptrToHandle((optr)forms), OptrToChunk(@URLText));
    int i, count;
    ulong realCount = 0;
    HTMLformData frm;

    /* loop to count forms in form array */
    count = @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT_COUNT();
    for (i = 0; i < count; i++) {
	@call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(i, &frm);
	if (frm.HFD_itemType == HTML_FORM_HEADER) realCount++;
    }
    return realCount;
}


/* Get magic cookie for window containing specified form.
 */
struct BrowserWindow *browserGetFormWindow(jseContext jsecontext,
					   struct BrowserForm *bf)
{
    optr text = ConstructOptr(OptrToHandle((optr)bf), OptrToChunk(@URLText));
    optr frame;

    frame = @call text::MSG_URL_TEXT_GET_FRAME_OBJ();
    return (struct BrowserWindow *)(@call frame::MSG_URL_FRAME_FIND_REAL_FRAME());
}


/* Get magic cookie for element array item.
 */
struct BrowserElement *browserGetElementItem(jseContext jsecontext,
					     struct BrowserForm *form,
					     ulong index)
{
    optr text = ConstructOptr(OptrToHandle((optr)form), OptrToChunk(@URLText));
    int i, count;
    HTMLformData head, el;
    struct BrowserElement *be = 0;

    @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(OptrToChunk((optr)form), &head);
    /* loop to find form array index of requested element index */
    count = @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT_COUNT();
    for (i = 0; i < count; i++) {
	@call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(i, &el);
	if ((el.HFD_formNumber == head.HFD_formNumber) &&
	    (el.HFD_itemType != HTML_FORM_HEADER) &&
	    (el.HFD_itemType != HTML_FORM_OPTION)) {
	    if (index == 0) {
		/* found it */
		be = (struct BrowserElement *)(ConstructOptr(OptrToHandle(text), (word)i));
		break;
	    } else {
		index--;
	    }
	}
    }
    return be;
}


/* Get magic cookie for element array item from name.
 */
struct BrowserElement *browserGetElementItemFromName(jseContext jsecontext,
						     struct BrowserForm *form,
						     const jsecharptr name)
{
    optr text = ConstructOptr(OptrToHandle((optr)form), OptrToChunk(@URLText));
    HTMLformData head;
    optr pool = @call text::MSG_HTML_TEXT_GET_NAME_POOL();
    NameToken nameT;
    struct BrowserElement *be = 0;
    word ret;

    if (*name) {
	nameT = NamePoolTokenizeDOS(pool, name, TRUE);
	@call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(OptrToChunk((optr)form), &head);
	ret = @call text::MSG_URL_TEXT_FIND_ELEMENT_FROM_NAME(nameT, head.HFD_formNumber);
	if (ret != 0xffff) {
	    /* found it */
	    be = (struct BrowserElement *)(ConstructOptr(OptrToHandle(text), (word)ret));
	}
	NamePoolReleaseToken(pool, nameT);
    }
    return be;
}


/* Get number of elements.
 */
ulong browserGetElementsLength(jseContext jsecontext,
			       struct BrowserForm *form)
{
    optr text = ConstructOptr(OptrToHandle((optr)form), OptrToChunk(@URLText));
    int i, count;
    ulong realCount = 0;
    HTMLformData head, el;

    @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(OptrToChunk((optr)form), &head);
    /* loop to count elements in element array */
    count = @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT_COUNT();
    for (i = 0; i < count; i++) {
	@call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(i, &el);
	if ((el.HFD_formNumber == head.HFD_formNumber) &&
	    (el.HFD_itemType != HTML_FORM_HEADER) &&
	    (el.HFD_itemType != HTML_FORM_OPTION))
	    realCount++;
    }
    return realCount;
}


/* Get magic cookie for window containing specified element.
 */
struct BrowserWindow *browserGetElementWindow(jseContext jsecontext,
					      struct BrowserElement *be)
{
    optr text = ConstructOptr(OptrToHandle((optr)be), OptrToChunk(@URLText));
    optr frame;

    frame = @call text::MSG_URL_TEXT_GET_FRAME_OBJ();
    return (struct BrowserWindow *)(@call frame::MSG_URL_FRAME_FIND_REAL_FRAME());
}


/* Get form number containing specified element.
 */
word browserGetElementForm(jseContext jsecontext,
			   struct BrowserElement *be)
{
    Boolean formFound = FALSE;
    word i = (word)(OptrToChunk((optr)be));
    word nForm = 0;
    HTMLformData el;
    optr text = ConstructOptr(OptrToHandle((optr)be), OptrToChunk(@URLText));

    while (i) {
	@call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(i-1, &el);
	if (el.HFD_itemType == HTML_FORM_HEADER) {
	    if (formFound) {
		nForm++;
	    } else {
		formFound = TRUE;
	    }
	}
	i--;
    }
    return nForm;
}


/* Check for option array item.
 */
Boolean browserGetOptionItem(jseContext jsecontext,
			     struct BrowserElement *elem,
			     ulong index)
{
    optr text = ConstructOptr(OptrToHandle((optr)elem), OptrToChunk(@URLText));
    int i, count;
    HTMLformData head, el;
    Boolean found = FALSE;

    @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(OptrToChunk((optr)elem), &head);
    /* loop to find form array index of requested option index */
    count = @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT_COUNT();
    for (i = 0; i < count; i++) {
	@call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(i, &el);
	if ((el.HFD_formNumber == head.HFD_formNumber) &&
	    (el.HFD_itemType != HTML_FORM_HEADER) &&
	    (el.HFD_itemType == HTML_FORM_OPTION) &&
	    (el.HFD_var.option.menuElement == OptrToChunk((optr)elem)) &&
	    !(el.HFD_var.option.flags & HTML_OPTION_DELETED)) {
	    if (index == 0) {
		/* found it */
		found = TRUE;
		break;
	    } else {
		index--;
	    }
	}
    }
    return found;
}


/* Get number of options.
 */
ulong browserGetOptionsLength(jseContext jsecontext,
			      struct BrowserElement *elem)
{
    optr text = ConstructOptr(OptrToHandle((optr)elem), OptrToChunk(@URLText));
    int i, count;
    ulong realCount = 0;
    HTMLformData head, el;

    @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(OptrToChunk((optr)elem), &head);
    /* loop to count options in option array */
    count = @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT_COUNT();
    for (i = 0; i < count; i++) {
	@call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(i, &el);
	if ((el.HFD_formNumber == head.HFD_formNumber) &&
	    (el.HFD_itemType != HTML_FORM_HEADER) &&
	    (el.HFD_itemType == HTML_FORM_OPTION) &&
	    (el.HFD_var.option.menuElement == OptrToChunk((optr)elem)) &&
	    !(el.HFD_var.option.flags & HTML_OPTION_DELETED))
	    realCount++;
    }
    return realCount;
}


#pragma codeseg BrowserJSRare
#pragma option -dc-

@ifndef JS_ERROR_DIALOG
/* all access is from process thread, so no synchronization problems */
MemHandle jsErrorString = 0;
@endif

TCHAR *getDialogString(const char *str, MemHandle *han)
{
    unsigned char *p = str;
    TCHAR *q;
#ifndef DO_DBCS
    unsigned char x;
#endif
#ifdef DO_DBCS
    word len, status, backup;
    DosCodePage cp = G_codePage;
    TCHAR *r;
#endif

    *han = MemAlloc((STRLENSB(str)+1)*sizeof(TCHAR), HF_DYNAMIC, HAF_STANDARD_LOCK);
    if (*han) {
	q = MemDeref(*han);
#ifdef DO_DBCS
	len = strlensbcs(str)+1;
	LocalDosToGeos(q, (char *)p, &len, DEFCHAR, &cp, 0, &status, &backup);
	r = q;
	while (*q) {
	    if (*q == C_CR && *(q+1) == C_LF) {
		*r++ = C_CR;
		q += 2;
	    } else if (*q == C_LF) {
		*r++ = C_CR;
		q += 1;
	    } else {
		*r++ = *q++;
	    }
	}
	*r = C_NULL;
#else
	while (*p) {
	    if (*p >= 128) {
		x = HTMLTranslateCharNum(*p);
		*q++ = x ? x : *p;
		p++;
	    } else if (*p == C_CR && *(p+1) == C_LF) {
		*q++ = C_CR;
		p += 2;
	    } else if (*p == C_LF) {
		*q++ = C_CR;
		p += 1;
	    } else {
		*q++ = *p++;
	    }
	}
	*q = C_NULL;
#endif
	return MemDeref(*han);
    } else {
	return NULL;
    }
}

static void JSE_CFUNC FAR_CALL _export
ErrorFunction(jseContext jsecontext, const char _FAR_ *ErrorString)
{
@ifdef JS_ERROR_DIALOG
    TCHAR *p;
    MemHandle pH;
@endif

    /* flag error in browser */
    if (browserFrameObj) {
	@call browserFrameObj::MSG_URL_FRAME_SET_JS_ERROR();
    }

@ifdef COMPILE_OPTION_AUTO_BROWSE
    /* for auto-browse, log JS error (cr/lf version) */
     if (bulkTestCount) {
	 ABLog("Script error:\r\n%s\r\n", ErrorString);
	 return;
     }
@endif

@ifdef JS_ERROR_DIALOG
    /* convert cr-lf to cr, convert lf to cr */
    p = getDialogString(ErrorString, &pH);
    if (!p) return;
    MemLock(OptrToHandle(@MsgScriptError));
    /* Insert specific error text into generic one via placeholder */
    browserDialog(LMemDeref(@MsgScriptError), p, 0,
		  (CDT_ERROR << CDBF_DIALOG_TYPE_OFFSET) |
		  (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET));
    MemUnlock(OptrToHandle(@MsgScriptError));
    if (pH)
	MemFree(ph);
@else
    /* hold latest error string */
    if (jsErrorString) MemFree(jsErrorString);
    (void)getDialogString(ErrorString, &jsErrorString);
    if (jsErrorString)
	MemUnlock(jsErrorString);
@endif
}

#pragma codeseg
#pragma option -dc

#pragma code_seg(ContinueSegment)
#pragma option -dc-

extern Boolean G_stopped;

static jsebool JSE_CFUNC FAR_CALL _export
ContinueFunction()
{
    word res;
    dword now = TimerGetCount();

    /* easiest check */
    if (G_stopped) return FALSE;

    /* else, check for time since script started and ask user */
    /* (there is a small timing hole here since LoadURLCallback also
       sets startInterpret, but it is non-fatal) */
    if ((now > startInterpret) && (now - startInterpret) > RUNAWAY_JS_TIME) {
	runawayCount++;
@ifdef COMPILE_OPTION_AUTO_BROWSE
        /* for auto-browse, log runaway JS (cr/lf version) */
        if (bulkTestCount) {
	    if (runawayCount > RUNAWAY_MAX_TIMES) {
		ABLog("Runaway script: aborted\r\n");
		return FALSE;  /* abort */
	    } else {
		ABLog("Runaway script: %d\r\n", runawayCount);
		/* reset timer for another loop */
		startInterpret = TimerGetCount();
		return TRUE;  /* continue */
	    }
	}
@endif
	if (runawayCount > RUNAWAY_MAX_TIMES) return FALSE;  /* stop script */
	jseLeave();  /* callback from jseInterpret, et al */
	res = UserStandardDialogOptr(
	    0, 0, 0, 0,
	    @MsgRunawayScript,
	    (CDT_WARNING << CDBF_DIALOG_TYPE_OFFSET) |
	    (GIT_AFFIRMATION << CDBF_INTERACTION_TYPE_OFFSET));
	jseEnter();
	/* reset timer for another loop */
	startInterpret = TimerGetCount();  /* reset for YES or NO */
	if (res == IC_YES) return FALSE;
    }

    return TRUE;
}

#define C_COMMENT 0x8000
#define CC_COMMENT 0x4000
#define QUOTE_CHAR 0x00ff

char pbuf[3] = {0, 0, 0};  /* only accessed by single parsing thread */

word HandleScriptChar(word flags, char c, char p)
{
    if (flags & CC_COMMENT) {
	if (!c || c==EOF || c==C_CR || c==C_LF ||
	    (pbuf[0]=='-' && pbuf[1]=='-' && p=='>')) {
	    flags &= ~CC_COMMENT;
	}
    } else if (flags & C_COMMENT) {
	if (!c || c==EOF || (c=='/' && p=='*')) {
	    flags &= ~C_COMMENT;
	}
    } else if (flags & QUOTE_CHAR) {
	if (!c || c==EOF ||
            (c==(flags & QUOTE_CHAR) && p!='\\')) {
	    flags &= ~QUOTE_CHAR;
	}
    } else {
	if ((c=='"' || c=='\'') && p!='\\') {
	    flags = (flags & ~QUOTE_CHAR) | c;
	} else if (c=='*' && p=='/') {
	    flags |= C_COMMENT;
	} else if (c=='/' && p=='/') {
	    flags |= CC_COMMENT;
	}
    }
    return flags;
}

static jsebool JSE_CFUNC FAR_CALL
GetSourceFunction(jseContext jsecontext,
                  struct jseToolkitAppSource *ToolkitAppSource,
                  jseToolkitAppSourceFlags flag)
{
    jsebool ret = False;
    BrowserScriptSource *bss;
    word len,i;
    char c = 0, *p, prev = 0;
    TCHAR buf[HTML_STATIC_BUF], *code;
    word size,cnt;
    word charFlags = 0;

    switch(flag)
    {
      case jseNewOpen:
        ToolkitAppSource->code = NULL;  // no buffer yet
        i = sscanf(ToolkitAppSource->name, "%lx", &(ToolkitAppSource->userdata));
                                        // retrieve pointer to source descriptor
        ret = (i==1);                   // success if pointer was found
        break;

      case jseGetNext:
        if(ToolkitAppSource->code)      // release line buffer
          free(ToolkitAppSource->code);

        bss = (BrowserScriptSource *)(ToolkitAppSource->userdata);

        if(bss->BSS_isToken)            // lock down token for access
          NamePoolCopy(namePool, buf, sizeof(buf), bss->BSS_data.token.code, &code);

        len = 128;
        p = malloc(len);                // allocate minimum buffer
        i = 0;
        cnt = 0;

        do {
	  pbuf[0] = pbuf[1]; pbuf[1] = pbuf[2]; pbuf[2] = prev = c;
	  /* handle escaped backslash: make sure we don't treat the previous
	     backslash as an escape for the next character */
	  if (pbuf[1] == '\\' && c == '\\') {
	      pbuf[2] = 0;
	      prev = 0;
	  }
          if(bss->BSS_isToken) {        // get byte from token string?
            c = code[bss->BSS_offset+i];
	    charFlags = HandleScriptChar(charFlags, c, prev);
	  }
          else
          {
            if(!cnt)                    // refill buffer if necessary
            {
              cnt = HAL_COUNT(HugeArrayLock(bss->BSS_data.array.vmf,
                                            bss->BSS_data.array.vmb,
                                            bss->BSS_offset+i, (void**)&code, &size));
            }

            if(cnt)                     // got more data to read now?
            {
              c = *(((char *)code)++);            // get one character
              cnt--;                    // count down remaining data
            }
            else
              c = 0;                    // no more data

	    charFlags = HandleScriptChar(charFlags, c, prev);

            if((c && !cnt) || (c == '\n' && prev != '\\' && !charFlags))// done with data in block?
              HugeArrayUnlock(code);    // unlock it
          }

          if(c)                         // got data?
          {
            p[i++] = c;                 // put it into buffer
            if(i==len)                  // no more room for next character?
            {
              len += 128;               // expand buffer
              p = realloc(p, len);
            }
          }
        } while(c && (c != '\n' || prev == '\\' || charFlags));        // until end of line
        p[i] = 0;                       // terminate source buffer

        if(bss->BSS_isToken)            // release copy of long token string
          NamePoolDestroyIfDynamic(code);

        ToolkitAppSource->code = p;     // return new line buffer
        bss->BSS_offset += i;           // advance pointer into stream

        ret = (i>0);                    // success if anything was read
        break;

      case jseClose:
        if(ToolkitAppSource->code)      // release last line buffer
          free(ToolkitAppSource->code);
        ret = True;                     // that's it
        break;
    }

    /* we must cast the return type to dword because this is what
       DispatchToClient is declared as */
    return (dword)ret;
}

#pragma codeseg
#pragma option -dc

/***************************************************************************
 *              Mapping of browser elements to JavaScript variables
 ***************************************************************************
 *
 * These routines return variable references that have to be
 * explicitly destroyed by the caller.
 */

jseVariable JSImageObject(jseContext jsecontext,optr frame,word i)
{
    jseVariable v1,v2,v3,v4;

    /* return document.images.images[i] of specified window */
    jseAssert();
    v1 = JSWindowObject(jsecontext, frame);
    v2 = jseMemberEx(jsecontext,v1,"__document",jseTypeUndefined, jseCreateVar);
    jseDestroyVariable(jsecontext, v1);
    v3 = jseMemberEx(jsecontext,v2,"__images",jseTypeUndefined, jseCreateVar);
    jseDestroyVariable(jsecontext, v2);
    v4 = jseIndexMemberEx(jsecontext,v3,i,jseTypeUndefined, jseCreateVar);
    jseDestroyVariable(jsecontext, v3);

    return v4;
}

jseVariable JSLinkObject(jseContext jsecontext,optr frame,word i)
{
    jseVariable v1,v2,v3,v4;

    /* return document.links[i] of specified window */
    jseAssert();
    v1 = JSWindowObject(jsecontext, frame);
    v2 = jseMemberEx(jsecontext,v1,"__document",jseTypeUndefined, jseCreateVar);
    jseDestroyVariable(jsecontext, v1);
    v3 = jseMemberEx(jsecontext,v2,"__links",jseTypeUndefined, jseCreateVar);
    jseDestroyVariable(jsecontext, v2);
    v4 = jseIndexMemberEx(jsecontext,v3,i,jseTypeUndefined, jseCreateVar);
    jseDestroyVariable(jsecontext, v3);

    return v4;
}

jseVariable JSFormObject(jseContext jsecontext,optr text,word i)
{
    HTMLformData el;
    jseVariable v1,v2,v3,v4;
    word nForm;
    optr frame;

    nForm = 0;
    while(i>0)                          // Search all previous elements
    {
      @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(i-1, &el);
      if(el.HFD_itemType == HTML_FORM_HEADER)
        nForm++;
      i--;                              // Go back to start of list
    }

    frame = @call text::MSG_URL_TEXT_GET_FRAME_OBJ();
    frame = @call frame::MSG_URL_FRAME_FIND_REAL_FRAME();

    /* return document.forms[nForm] */
    jseAssert();
    v1 = JSWindowObject(jsecontext, frame);
    v2 = jseMemberEx(jsecontext,v1,"__document",jseTypeUndefined, jseCreateVar);
    jseDestroyVariable(jsecontext, v1);
    v3 = jseMemberEx(jsecontext,v2,"__forms",jseTypeUndefined, jseCreateVar);
    jseDestroyVariable(jsecontext, v2);
    v4 = jseIndexMemberEx(jsecontext,v3,nForm,jseTypeUndefined, jseCreateVar);
    jseDestroyVariable(jsecontext, v3);

    return v4;
}

jseVariable JSElementObject(jseContext jsecontext,optr text,word i)
{
    HTMLformData el;
    jseVariable v1,v2,v3,v4,v5,v6;
    Boolean formFound;
    word nForm, nElem;
    optr frame;

    formFound = FALSE;
    nForm = nElem = 0;
    while(i>0)                          // Search all previous elements
    {
      @call text::MSG_HTML_TEXT_GET_FORM_ELEMENT(i-1, &el);
      if(el.HFD_itemType == HTML_FORM_HEADER)
      {
        if(formFound)
          nForm++;                      // Count forms before ours
        else
          formFound = TRUE;
      }
      else if(el.HFD_itemType != HTML_FORM_OPTION)
      {
        if(!formFound)                  // Count elements before ours
          nElem++;
      }
      i--;                              // Go back to start of list
    }

    if(formFound)
    {
      frame = @call text::MSG_URL_TEXT_GET_FRAME_OBJ();
      frame = @call frame::MSG_URL_FRAME_FIND_REAL_FRAME();

      /* return document.forms[nForm].elements[nElem] */
      jseAssert();
      v1= JSWindowObject(jsecontext, frame);
      v2 = jseMemberEx(jsecontext,v1,"__document",jseTypeUndefined, jseCreateVar);
      jseDestroyVariable(jsecontext, v1);
      v3 = jseMemberEx(jsecontext,v2,"__forms",jseTypeUndefined, jseCreateVar);
      jseDestroyVariable(jsecontext, v2);
      v4 = jseIndexMemberEx(jsecontext,v3,nForm,jseTypeUndefined, jseCreateVar);
      jseDestroyVariable(jsecontext, v3);
      v5 = jseMemberEx(jsecontext,v4,"__elements",jseTypeUndefined, jseCreateVar);
      jseDestroyVariable(jsecontext, v4);
      v6 = jseIndexMemberEx(jsecontext,v5,nElem,jseTypeUndefined, jseCreateVar);
      jseDestroyVariable(jsecontext, v5);
    }
    else
      v6 = NULL;

    return v6;
}

/***************************************************************************
 *              Init/Exit JavaScript subsystem
 ***************************************************************************/

#pragma codeseg BrowserJSRare
#pragma option -dc-

void InitBrowserJS(void)
{
   MemHandle idBlock = 0;
   word idSize;
   char *appCodeName = NULL, *appName = NULL, *appVersion = NULL, *platform = NULL, *language = NULL;
   EC(int ver;)
   struct jseExternalLinkParameters LinkParms;
   extern jseVariable globalObject;

   /* all ISDK application must make at least one context and initialize the parameters */

   jseEnter();
   EC(ver =) jseInitializeEngine();
   assert( JSE_ENGINE_VERSION_ID == ver );

   /* Set up the linkParms structure and create a context */
   memset(&LinkParms,0,sizeof(LinkParms));
   LinkParms.PrintErrorFunc = ErrorFunction;
   LinkParms.MayIContinue = ContinueFunction;
   LinkParms.GetSourceFunc = GetSourceFunction;
   /* allow extra parameters and lenient conversion -- brianc 8/16/00 */
   LinkParms.options = jseOptLenientConversion|jseOptIgnoreExtraParameters;
   jsecontext = jseInitializeExternalLink(NULL,&LinkParms,"","");
   if(NULL == jsecontext)
   {
     /*  printf("Last Api Error: %s\n",jseGetLastApiError());  */
     jseLeave();
     return;
   }

   /* save global */
   globalObject = jseGlobalObject(jsecontext);

   /* add libraries for all of the ECMA and BROWSER objects */
   LoadLibrary_All(jsecontext);
   /*printf("Last Api Error: %s\n",jseGetLastApiError());*/
   InitializeInternalLib_BrowserLib(jsecontext);

   /* this is reasonably fast, so it is okay to do each time we initialize
      the JS engine */
   if (InitFileReadStringBlock(HTMLVIEW_CATEGORY, "browserID", &idBlock, 0, &idSize)) {
       idBlock = 0;  /* not in .ini file */
   }
   if (idBlock) {
       /* parse comma-separated strings from block */
       appCodeName = MemLock(idBlock);
       appName = strchr(appCodeName, ',');
       if (appName) {
	   *appName++ = C_NULL;
	   appVersion = strchr(appName, ',');
       }
       if (appVersion) {
	   *appVersion++ = C_NULL;
	   platform = strchr(appVersion, ',');
       }
       if (platform) {
	   *platform++ = C_NULL;
	   language = strchr(platform, ',');
       }
       if (language) {
	   *language++ = C_NULL;
       }
   }
   /* Set up default properties of the browser */
#ifdef DO_DBCS
   browserGeneralInfo(jsecontext,
     (appCodeName && *appCodeName) ? G2D(appCodeName) : "Mozilla",   // appCodeName
     (appName && *appName) ? G2D(appName) : "WebMagick3",              // appName
                                                                // appVersion
     (appVersion && *appVersion) ? G2D(appVersion) : "4.06 (WinNT; U; WebMagick3)",
     (platform && *platform) ? G2D(platform) : "GEOS",               // platform
     (language && *language) ? G2D(language) : "en",                 // language
     FALSE);
#else
   browserGeneralInfo(jsecontext,
     (appCodeName && *appCodeName) ? appCodeName : "Mozilla",   // appCodeName
     (appName && *appName) ? appName : "WebMagick3",              // appName
                                                                // appVersion
     (appVersion && *appVersion) ? appVersion : "4.06 (WinNT; U; WebMagick3)",
     (platform && *platform) ? platform : "GEOS",               // platform
     (language && *language) ? language : "en",                 // language
     FALSE);
#endif
   if (idBlock) MemUnlock(idBlock);
   /* XXX: add mime types */
   browserAddMimeType(jsecontext, 0);
   /* XXX: add plugins */
   browserAddPlugin(jsecontext, 0);
   jseLeave();
}

void ExitBrowserJS(void)
{
    jseEnter();
    /* Cleanup browser's data structures */
    browserCleanup(jsecontext);

     /* Shutdown and clean up the interpreter session */
    jseTerminateExternalLink( jsecontext );
    jseTerminateEngine();
    jseLeave();
}

#pragma codeseg
#pragma option -dc

@endif
